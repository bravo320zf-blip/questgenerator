<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HeroQuest Quest & Dungeon Generator</title>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #000000;
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            position: relative;
            width: 988px;
            height: 760px;
            cursor: crosshair;
        }

        #backgroundImage {
            width: 100%;
            height: 100%;
            display: block;
            opacity: 0.7;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #controls {
            margin: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 15px;
            font-size: 14px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }

        button:hover {
            background-color: #45a049;
        }

        .mode-btn {
            background-color: #b22222;
        }

        .mode-btn:hover {
            background-color: #8b0000;
        }

        /* Map Maker UI */
        #mapMakerToolbar {
            display: none;
            background: #ffffff;
            padding: 10px;
            color: white;
            gap: 8px;
            width: 988px;
            box-sizing: border-box;
            justify-content: center;
            border-bottom: 2px solid #444;
            flex-wrap: wrap;
            /* Allows buttons to go to a second line if needed */
        }

        .tile-option {
            border: 1px solid #555;
            padding: 6px 8px;
            cursor: pointer;
            background: #333;
            font-size: 11px;
            /* Slightly smaller font to fit more buttons */
            border-radius: 3px;
            white-space: nowrap;
        }

        .tile-option:hover {
            background: #444;
            border-color: #777;
        }

        .tile-option.selected {
            border-color: #4CAF50;
            background: #2e4d30;
            font-weight: bold;
        }

        /* Vault Modal */
        .vault-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 4px solid #b22222;
            z-index: 1000;
            width: 400px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .vault-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
        }

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }

        #questInfo {
            width: 988px;
            background-color: #d3d3d3;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            box-sizing: border-box;
        }

        #questNotes {
            width: 988px;
            margin-top: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .room {
            background-color: #ffffff;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .room-letter {
            font-weight: bold;
            font-size: 18px;
            color: #b22222;
        }

        .monster-image {
            width: 40px;
            height: 40px;
            vertical-align: middle;
            margin-right: 5px;
        }

        #backgroundImage.hidden {
            display: none;
        }

.asset-icon {
    width: 50px;
    height: 50px;
    margin: 3px; /* Slightly reduced margin to ensure fit */
    border: 1px solid #ccc;
    border-radius: 4px;
    background: #f9f9f9;
    object-fit: contain;
    padding: 2px;
    box-sizing: border-box;
    vertical-align: middle;
    display: inline-block; /* Ensures they sit side-by-side */
}

        .asset-icon:hover {
            border-color: #673ab7;
            background: #eee;
            box-shadow: 0 0 5px rgba(103, 58, 183, 0.5);
        }

        #tileSidePanel .tile-option {
            display: block;
            background: #333;
            border: 1px solid #555;
            padding: 8px;
            margin-bottom: 4px;
            text-align: center;
            font-size: 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            box-sizing: border-box;
            /* ADD THIS LINE */
        }

        #tileSidePanel .tile-option:hover {
            background: #444;
            border-color: #4CAF50;
        }

        #tileSidePanel .tile-option.selected {
            background: #2e4d30;
            border-color: #4CAF50;
            font-weight: bold;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Highlights the 1x1 buttons as "Utility" buttons */
        #tileSidePanel .tile-option[onclick*="1, 1"] {
            border-color: #607d8b;
            color: #b0bec5;
        }

        /* Sidebar Panels General */
        /* Sidebar Panels - Simple & Static */
        .side-panel {
            position: fixed;
            top: 120px;
            width: 280px;
            max-height: 80vh;
            background: #222;
            color: white;
            z-index: 2000;
            border: 2px solid #444;
            border-radius: 8px;
            box-sizing: border-box;
            display: none;
            /* Hidden by default */
            overflow-y: auto;
            padding: 15px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .side-panel.left {
            left: 20px;
            border-color: #4CAF50;
        }

        .side-panel.right {
            right: 20px;
            border-color: #673ab7;
        }

        /* Remove the tab styling entirely */
        .panel-tab {
            display: none !important;
        }

        .panel-content {
            height: auto;
        }

        .tile-option {
            padding: 8px;
            margin-bottom: 5px;
            background: #333;
            border: 1px solid #555;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            color: white;
        }

        .tile-option:hover {
            background: #444;
            border-color: #4CAF50;
        }

        .tile-option.selected {
            background: #2e4d30;
            border-color: #4CAF50;
            font-weight: bold;
        }

        .tile-option {
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
        }

        .tile-option:hover {
            background: #444;
            border-color: #4CAF50;
        }

        /* Prevent screen scrolling when dragging on canvas */
        canvas {
            touch-action: none;
        }

        /* Auth Modal Styles */
        .auth-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 4px solid #b22222;
            z-index: 1000;
            width: 400px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .auth-input {
            width: 100%;
            padding: 8px;
            margin: 10px 0;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        .auth-btn {
            width: 100%;
            margin-top: 10px;
            padding: 10px;
            background-color: #b22222;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-weight: bold;
        }

        .auth-btn:hover {
            background-color: #8b0000;
        }

        .auth-switch {
            text-align: center;
            margin-top: 15px;
            font-size: 13px;
            cursor: pointer;
            color: #b22222;
            text-decoration: underline;
        }

        /* User Profile & Social */
        .profile-chip {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            background: #333;
            padding: 5px 10px;
            border-radius: 20px;
            border: 1px solid #555;
        }

        .profile-chip:hover {
            background: #444;
            border-color: #777;
        }

        .profile-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #666;
            object-fit: cover;
        }

        .profile-name {
            color: white;
            font-size: 13px;
            font-weight: bold;
        }

        .room-section {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 15px;
            background: #fdfdfd;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Hamburger Menu & UI Redesign */
        .hamburger-menu {
            position: relative;
            display: inline-block;
            margin-left: 10px;
            z-index: 500;
        }

        .menu-btn {
            background: #333;
            color: white;
            font-size: 24px;
            padding: 5px 15px;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #555;
            z-index: 2001;
            line-height: 1;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            top: 100%;
            margin-top: 5px;
            background-color: #2c2c2c;
            min-width: 250px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.5);
            z-index: 500;
            border-radius: 4px;
            overflow: hidden;
            flex-direction: column;
        }

        /* Help Modal Styles */
        .help-sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .help-sidebar::-webkit-scrollbar-thumb {
            background: #ccc;
        }

        .help-tab {
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            color: #555;
            transition: background 0.2s;
            font-size: 14px;
        }

        .help-tab:hover {
            background: #e0e0e0;
        }

        .help-tab.active {
            background: #fff;
            color: #b22222;
            font-weight: bold;
            border-right: 3px solid #b22222;
        }

        .help-panel {
            display: none;
            animation: fadeIn 0.2s;
        }

        .help-panel.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        mark.highlight {
            background-color: #ffeb3b;
            color: black;
            padding: 0 2px;
            border-radius: 2px;
        }

        .dropdown-content button {
            width: 100%;
            text-align: left;
            border-radius: 0;
            margin: 0;
            padding: 12px 16px;
            background: none;
            border: none;
            border-bottom: 1px solid #444;
            color: #ddd;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dropdown-content button:hover {
            background-color: #444;
        }

        .dropdown-content div {
            box-sizing: border-box;
        }

        /* Toggle Button */
        .toggle-btn {
            background: #555;
            transition: background 0.3s;
            color: white;
        }

        .toggle-active {
            background: #4CAF50 !important;
            font-weight: bold;
        }

        /* Controls Container */
        #controls {
            justify-content: center;
            position: relative;
            padding-right: 0;
            width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>

<body>



<div id="controls">
    <button id="generateButton">Generate New Quest</button>
    
    <!-- NEW UNIFIED BUTTON -->
    <button id="unifiedEditBtn" class="mode-btn" onclick="toggleUnifiedEditMode()">Enter Editor Mode</button>

    <!-- Toggle Button for Labels -->
    <input type="checkbox" id="showRoomNumbers" checked style="display:none;" onchange="drawBoard()">
    <button id="roomLabelToggleBtn" class="toggle-btn" onclick="toggleRoomLabels()">Show Room Labels</button>
    <button id="layoutToggleBtn" onclick="toggleLayoutSource()">Switch to Custom Layout</button>

    <!-- Hamburger Menu (Kept as is) -->
    <div class="hamburger-menu">
        <button class="menu-btn" onclick="toggleMenu()">‚ò∞</button>
        <div id="mainMenuDropdown" class="dropdown-content">
            <!-- ... keep existing menu content ... -->
             <div id="userProfileDisplay"
                style="display:none; padding:10px 15px; border-bottom:1px solid #444; color:white; cursor:pointer; align-items:center; gap:10px;"
                onclick="toggleProfileModal()">
                <img id="userAvatarSmall" class="profile-avatar" src=""
                    style="width:24px;height:24px;vertical-align:middle;border-radius:50%;">
                <span id="userNameSmall" class="profile-name">Player</span>
            </div>
            <button id="authBtn" onclick="toggleAuthModal()">Login / Register</button>
            <button id="vaultBtn" onclick="toggleVault()">üìÇ My Vault</button>
            <button id="communityBtn" onclick="toggleCommunity()">üè∞ Community Vault</button>
            <button id="saveVaultBtn" onclick="saveCurrentLayout()">üíæ Save to Local</button>
            <button id="shareBtn" onclick="toggleShareModal()">üì§ Share Quest</button>
            <div style="border-top:1px solid #555; margin:5px 0;"></div>
            <button id="downloadButton" onclick="downloadQuest('png')">üñºÔ∏è Download PNG</button>
            <button id="pdfButton" onclick="downloadQuest('pdf')">üìÑ Download PDF</button>
            <button onclick="toggleHelp()">‚ùì Help</button>
        </div>
    </div>
</div>



    <!-- Map Maker Toolbar (Restored) -->
    <div id="mapMakerToolbar"
        style="display:none; background:#2c2c2c; padding:8px 15px; border-bottom:1px solid #444; align-items:center; gap:15px; color:#ddd; font-size:14px; width:100%; box-sizing:border-box;">
        <span style="font-weight:bold; color:#fff;">MAP EDITOR</span>
        <div style="width:1px; height:20px; background:#555;"></div>
        <span style="flex:1;"></span>
        <span>Rotation: <span id="rotVal"
                style="background:#444; padding:2px 6px; border-radius:4px; color:#fff; font-family:monospace;">0</span>¬∞</span>
        <span style="font-size:11px; color:#888;">(Scroll to Rotate)</span>
    </div>
	
	<!-- Text Label Editor Toolbar -->
<!-- Text Label Editor Toolbar (Larger & clearer) -->
<div id="textEditorToolbar" style="display:none; position:fixed; bottom:20px; left:20px; z-index:2000; background:white; border:2px solid #333; padding:10px; border-radius:8px; box-shadow:0 0 15px rgba(0,0,0,0.5); width:280px; font-family:Arial, sans-serif; box-sizing: border-box;">
    
    <label style="font-size:12px; font-weight:bold; color:#333; display:block; margin-bottom:4px;">Label Text:</label>
    <textarea id="textLabelInput" rows="2" style="width:100%; box-sizing:border-box; margin-bottom:8px; font-size:13px; padding:5px; border:1px solid #ccc; border-radius:4px; resize:vertical;" oninput="updateActiveTextLabel()"></textarea>
    
    <label style="font-size:11px; font-weight:bold; color:#555; display:block; margin-bottom:4px;">Add Arrow:</label>
    <div style="display:flex; justify-content:space-between; margin-bottom:10px; gap:2px;">
        <button onclick="setTextArrow('none')" style="flex:1; padding:5px; font-size:12px; cursor:pointer; background:#eee; border:1px solid #ccc; border-radius:4px; color:#333;" title="No Arrow">üö´</button>
        <button onclick="setTextArrow('up')" style="flex:1; padding:5px; font-size:16px; cursor:pointer; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#333;">‚Üë</button>
        <button onclick="setTextArrow('down')" style="flex:1; padding:5px; font-size:16px; cursor:pointer; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#333;">‚Üì</button>
        <button onclick="setTextArrow('left')" style="flex:1; padding:5px; font-size:16px; cursor:pointer; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#333;">‚Üê</button>
        <button onclick="setTextArrow('right')" style="flex:1; padding:5px; font-size:16px; cursor:pointer; background:#fff; border:1px solid #ccc; border-radius:4px; font-weight:bold; color:#333;">‚Üí</button>
    </div>

    <div style="display:flex; justify-content:space-between; align-items:center; margin-top:5px; background:#f5f5f5; padding:5px; border-radius:4px;">
        <div style="display:flex; align-items:center; gap:5px;">
            <label style="font-size:11px; font-weight:bold;">Size:</label>
            <input type="number" id="textSizeInput" value="16" min="8" max="72" style="width:40px; padding:2px; font-size:12px;" onchange="updateActiveTextLabel()">
        </div>
        <div style="display:flex; align-items:center; gap:5px;">
            <label style="font-size:11px; font-weight:bold;">Color:</label>
            <input type="color" id="textColorInput" value="#000000" style="width:30px; height:25px; padding:0; border:none; cursor:pointer;" onchange="updateActiveTextLabel()">
        </div>
    </div>
    
    <div style="display:flex; justify-content:space-between; gap:5px; margin-top:10px;">
        <button onclick="deleteActiveTextLabel()" style="flex:1; background:#f44336; color:white; border:none; padding:8px; border-radius:4px; cursor:pointer; font-weight:bold; font-size:11px;">Delete</button>
        <button onclick="closeTextEditor()" style="flex:1; background:#555; color:white; border:none; padding:8px; border-radius:4px; cursor:pointer; font-weight:bold; font-size:11px;">Close</button>
    </div>
</div>

    <div id="helpModal" class="vault-modal"
        style="width: 850px; height: 600px; display:none; flex-direction:column; padding:0; overflow:hidden;">
        <!-- Header -->
        <div
            style="padding:15px; border-bottom:1px solid #ddd; display:flex; justify-content:space-between; align-items:center; background:#f9f9f9;">
            <h3 style="margin:0; color:#333;">Quest Generator Guide</h3>
            <input type="text" id="helpSearch" placeholder="Search help topics..." onkeyup="searchHelp()"
                style="padding:8px; border:1px solid #ccc; border-radius:4px; width:250px;">
            <button onclick="toggleHelp()"
                style="background:none; border:none; color:#666; font-size:20px; cursor:pointer;">&times;</button>
        </div>

        <!-- Body -->
        <div style="display:flex; flex:1; overflow:hidden;">
            <!-- Sidebar Tabs -->
            <div class="help-sidebar"
                style="width:200px; background:#f0f0f0; border-right:1px solid #ddd; overflow-y:auto;">
                <div class="help-tab active" onclick="switchHelpTab('tab-overview')">Overview</div>
                <div class="help-tab" onclick="switchHelpTab('tab-mapmaker')">Map Maker</div>
                <div class="help-tab" onclick="switchHelpTab('tab-questeditor')">Quest Editor</div>
                <div class="help-tab" onclick="switchHelpTab('tab-vaults')">Vaults</div>
                <div class="help-tab" onclick="switchHelpTab('tab-controls')">Controls</div>
                <div class="help-tab" onclick="switchHelpTab('tab-account')">Account</div>
            </div>

            <!-- Content Area -->
            <div id="helpContentArea" style="flex:1; padding:20px; overflow-y:auto; background:white;">
                <!-- Overview -->
                <div id="tab-overview" class="help-panel active">
                    <h2 style="margin-top:0;">Welcome to Quest Generator</h2>
                    <p>This tool allows you to create, edit, and share custom HeroQuest dungeon maps. You can design the
                        layout from scratch, place furniture and monsters, and print or save your creations.</p>
                    <hr>
                    <h3>Basic Workflow</h3>
                    <ol>
                        <li><strong>Design Layout:</strong> Use the <em>Map Maker</em> to paint rooms and corridors.
                        </li>
                        <li><strong>Generate:</strong> Use the <em>Generate New Quest</em> button to auto-populate
                            items, or
                            clear the board.</li>
                        <li><strong>Customize:</strong> Use <em>Edit Placed Items</em> to move, rotate, or delete
                            objects.
                        </li>
                        <li><strong>Save/Share:</strong> Use the <em>Vault</em> to save locally or share with the
                            community.
                        </li>
                    </ol>
                </div>

                <!-- Map Maker -->
                <div id="tab-mapmaker" class="help-panel">
                    <h2 style="margin-top:0;">Map Maker Mode</h2>
                    <p>Create your custom dungeon layout by painting tiles onto the grid.</p>
                    <h3>How to Use</h3>
                    <ul>
                        <li>Click <strong>Enter Map Maker</strong> to start.</li>
                        <li>Select a tile from the <strong>Tile Library</strong> on the left.</li>
                        <li><strong>Left-Click</strong> on the board to paint the selected tile.</li>
                        <li><strong>Right-Click</strong> to erase a tile.</li>
                        <li>Use the <strong>Scroll Wheel</strong> to rotate the tile before placing.</li>
                    </ul>
                    <h3>Tracing</h3>
                    <p>If you have a background image loaded (e.g., the original board), the editor adds a transparency
                        layer so you can trace over it accurately.</p>
                </div>

                <!-- Quest Editor -->
                <div id="tab-questeditor" class="help-panel">
                    <h2 style="margin-top:0;">Quest Editor</h2>
                    <p>Fine-tune the contents of your dungeon by placing and modifying individual items.</p>
                    <h3>Edit Controls</h3>
                    <ul>
                        <li><strong>Move:</strong> Left-Click and Drag an item to move it.</li>
                        <li><strong>Rotate:</strong> While dragging, scroll the <strong>Mouse Wheel</strong> to rotate
                            90
                            degrees.</li>
                        <li><strong>Delete:</strong> Right-Click any item to remove it.</li>
                    </ul>
                    <h3>Asset Library</h3>
                    <p>Open the <strong>Asset Library</strong> to drag and drop new Monsters, Furniture, Doors, and
                        Walls
                        into your dungeon.</p>
                </div>

                <!-- Vaults -->
                <div id="tab-vaults" class="help-panel">
                    <h2 style="margin-top:0;">Vault System</h2>
                    <h3>My Vault (Local)</h3>
                    <p>Saves your quests to your browser's local storage.</p>
                    <ul>
                        <li><strong>Save:</strong> Click "Save to Local" to store your current work.</li>
                        <li><strong>Load:</strong> Open "My Vault" and click a quest to load it.</li>
                    </ul>
                    <h3>Community Vault (Online)</h3>
                    <p>Share your creations with other users!</p>
                    <ul>
                        <li><strong>Share:</strong> Click "Share Quest" to upload to the public database.</li>
                        <li><strong>Play:</strong> Browse the Community Vault to play quests made by others.</li>
                    </ul>
                </div>

                <!-- Controls -->
                <div id="tab-controls" class="help-panel">
                    <h2 style="margin-top:0;">Controls Reference</h2>
                    <table style="width:100%; border-collapse:collapse;">
                        <tr style="background:#eee;">
                            <th style="padding:5px; text-align:left;">Action</th>
                            <th style="padding:5px; text-align:left;">Input</th>
                        </tr>
                        <tr>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Paint Tile</td>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Left Click</td>
                        </tr>
                        <tr>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Erase Tile</td>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Right Click</td>
                        </tr>
                        <tr>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Move Item</td>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Left Drag</td>
                        </tr>
                        <tr>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Rotate Item</td>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Mouse Wheel (while dragging)</td>
                        </tr>
                        <tr>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Delete Item</td>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Right Click</td>
                        </tr>
                        <tr>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Pan Preview</td>
                            <td style="padding:5px; border-bottom:1px solid #eee;">Left Drag (in Vaults)</td>
                        </tr>
                    </table>
                </div>

                <!-- Account -->
                <div id="tab-account" class="help-panel">
                    <h2 style="margin-top:0;">Account & Profile</h2>
                    <p>Create an account to share quests and rate community content.</p>
                    <ul>
                        <li><strong>Login/Register:</strong> Use email to create a secure account.</li>
                        <li><strong>Profile:</strong> Click your avatar in the menu to edit your Display Name and Bio.
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Left Side Tile Library -->
<div id="tileSidePanel" class="side-panel left" style="display:none;">
    <h3 style="margin:0 0 10px 0; border-bottom:1px solid #444; padding-bottom:5px; font-size:16px; color:white;">
        Tile Library</h3>
    
    <!-- NEW: Select Tool (Stops painting so you can drag items) -->
    <div class="tile-option" onclick="selectBrush(null)" style="background:#555; border-color:#888; margin-bottom:15px; font-weight:bold;">
        ‚úã Move / Select Item
    </div>

    <div style="margin-bottom:15px;">
        <h4 style="font-size:12px; color:#888; text-transform:uppercase; margin-bottom:8px;">Corridors</h4>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
            <div class="tile-option" onclick="selectBrush('corridor', 1, 1)">1x1 Corr</div>
            <div class="tile-option" onclick="selectBrush('corridor', 3, 1)">3x1 Corr</div>
        </div>
    </div>
    <!-- ... Rest of panel remains the same ... -->
    <div>
        <h4 style="font-size:12px; color:#888; text-transform:uppercase; margin-bottom:8px;">Rooms</h4>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
             <!-- Existing buttons... -->
             <div class="tile-option" onclick="selectBrush('room', 1, 1)">1x1</div>
             <div class="tile-option" onclick="selectBrush('room', 2, 2)">2x2</div>
             <div class="tile-option" onclick="selectBrush('room', 3, 2)">3x2</div>
             <div class="tile-option" onclick="selectBrush('room', 3, 3)">3x3</div>
             <div class="tile-option" onclick="selectBrush('room', 4, 3)">4x3</div>
             <div class="tile-option" onclick="selectBrush('room', 4, 4)">4x4</div>
             <div class="tile-option" onclick="selectBrush('room', 5, 3)">5x3</div>
             <div class="tile-option" onclick="selectBrush('room', 3, 5)">3x5</div>
             <div class="tile-option" onclick="selectBrush('room', 4, 5)">4x5</div>
             <div class="tile-option" onclick="selectBrush('room', 5, 4)">5x4</div>
        </div>
        <div class="tile-option" onclick="selectBrush('room', 6, 5)" style="margin-top:5px;">6x5 Center</div>
<div class="tile-option" onclick="clearMap()"
    style="background:#f44336 !important; border-color:#b71c1c; margin-top:5px; font-weight:bold;">
    Clear
</div>
    </div>
</div>
    <div id="exportArea" style="background-color: #ffffff; padding: 20px;">
        <div id="gameContainer">
            <img id="backgroundImage"
                src="https://static.wixstatic.com/media/b16479_4b02e58761c94bbbb257856298fbf46e~mv2.png"
                alt="HeroQuest Board" crossorigin="anonymous">
            <canvas id="gameCanvas" width="988" height="760"></canvas>
        </div>

        <div id="questInfo"></div>
        <div id="questNotes"></div>
    </div>

    <!-- Vault Popup (Redesigned) -->
    <!-- Vault Popup (Redesigned) -->
    <div id="vaultModal" class="vault-modal"
        style="width: 90vw; height: 80vh; max-width: 1400px; display: none; flex-direction: column; padding: 0;">
        <div
            style="padding: 15px 20px; border-bottom: 1px solid #ddd; background: #f5f5f5; display:flex; justify-content:space-between; align-items:center;">
            <h3 style="margin:0; color:#333;">My Vault</h3>
            <span onclick="toggleVault()"
                style="font-size:24px; cursor:pointer; color:red; font-weight:bold;">&times;</span>
        </div>
        <div style="display: flex; flex: 1; overflow: hidden;">
            <!-- Left: List -->
            <div id="vaultListSide"
                style="width: 320px; border-right: 1px solid #ccc; overflow-y: auto; background: #fff;">
                <div id="vaultList"></div>
            </div>
            <!-- Right: Preview -->
            <div
                style="flex: 1; background: #e0e0e0; overflow: hidden; position: relative; display:flex; flex-direction:column;">
                <div style="flex:1; overflow:auto; padding:20px;">
                    <div id="vaultPreviewContainer"
                        style="background: white; transform-origin: top left; min-height: 100%; box-shadow:0 0 10px rgba(0,0,0,0.1);">
                        <div style="padding:40px; text-align:center; color:#666;">Select a quest to preview</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="overlay" onclick="handleOverlayClick()"></div>

    <!-- Community Modal (Redesigned) -->
    <div id="communityModal" class="vault-modal"
        style="width: 90vw; height: 90vh; border-color: #673ab7; max-width:1600px; max-height:95vh; display:none; flex-direction:column; padding:0;">
        <!-- Header -->
        <div
            style="display:flex; justify-content:space-between; align-items:center; padding:10px 20px; border-bottom:1px solid #ddd;">
            <h3 style="margin:0; color:#673ab7;">Community Vault</h3>
            <span onclick="toggleCommunity()"
                style="color:red; font-weight:bold; font-size:24px; cursor:pointer; padding:0 10px;">&times;</span>
        </div>

        <!-- Three Column Layout -->
        <div style="display:flex; gap:0; flex-grow:1; overflow:hidden;">
            <!-- LEFT: Quest List (25%) -->
            <div
                style="width:25%; border-right:1px solid #ddd; display:flex; flex-direction:column; background:#f9f9f9;">
                <!-- Search and Sort at Top -->
                <div style="padding:10px; background:#fff; border-bottom:1px solid #ddd;">
                    <input type="text" id="communitySearch" placeholder="Search quests..." class="auth-input"
                        style="width:100%; margin-bottom:8px; box-sizing:border-box;" onkeyup="filterCommunityQuests()">
                    <select id="communitySort" class="auth-input" style="width:100%; margin:0; box-sizing:border-box;"
                        onchange="sortCommunityQuests()">
                        <option value="newest">Newest First</option>
                        <option value="rating">Top Rated</option>
                        <option value="comments">Most Comments</option>
                        <option value="myquests">My Quests</option>
                    </select>
                </div>
                <!-- Quest List -->
                <div id="communityListContainer" style="flex:1; overflow-y:auto; padding:5px;">
                    <div id="communityList">Loading...</div>
                </div>
            </div>

            <!-- CENTER: Preview (45%) -->
            <div id="questPreviewPanel"
                style="width:45%; border-right:1px solid #ddd; background:#eee; display:flex; flex-direction:column; position:relative; overflow:hidden;">
                <!-- Zoom Controls at Top Center -->
                <div
                    style="padding:10px; background:#fff; border-bottom:1px solid #ddd; display:flex; justify-content:center; align-items:center; gap:10px;">
                    <span style="font-size:12px; color:#666;">Zoom:</span>
                    <button onclick="zoomPreview(0.1)"
                        style="width:35px; height:35px; border-radius:4px; border:1px solid #ccc; background:white; color:#333; font-weight:bold; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center;">+</button>
                    <button onclick="zoomPreview(-0.1)"
                        style="width:35px; height:35px; border-radius:4px; border:1px solid #ccc; background:white; color:#333; font-weight:bold; font-size:18px; cursor:pointer; display:flex; align-items:center; justify-content:center;">‚àí</button>
                </div>
                <!-- Preview Content -->
                <div
                    style="flex:1; overflow:auto; padding:20px; display:flex; justify-content:center; align-items:flex-start;">
                    <div id="previewContainer"
                        style="background:white; transform-origin: center top; box-shadow:0 0 20px rgba(0,0,0,0.2); min-width:600px;">
                        <div style="color:#666; text-align:center; padding:40px;">Select a quest to preview</div>
                    </div>
                </div>
            </div>

            <!-- RIGHT: Comments & Rating (30%) -->
            <div id="commentsPanel"
                style="width:30%; background:#fff; display:flex; flex-direction:column; overflow:hidden;">
                <!-- Rating Section -->
                <div id="ratingSection" style="padding:15px; border-bottom:1px solid #ddd; background:#f9f9f9;">
                    <div style="text-align:center; margin-bottom:10px;">
                        <div id="averageRating" style="font-size:32px; color:#fbc02d;">‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ</div>
                        <div id="ratingCount" style="font-size:12px; color:#666;">No ratings yet</div>
                    </div>
                    <div id="userRatingInput" style="text-align:center; display:none;">
                        <div style="font-size:12px; color:#666; margin-bottom:5px;">Rate this quest:</div>
                        <div id="starRatingInput" style="font-size:24px; cursor:pointer;">
                            <span onclick="rateQuest(1)">‚òÜ</span>
                            <span onclick="rateQuest(2)">‚òÜ</span>
                            <span onclick="rateQuest(3)">‚òÜ</span>
                            <span onclick="rateQuest(4)">‚òÜ</span>
                            <span onclick="rateQuest(5)">‚òÜ</span>
                        </div>
                    </div>
                </div>

                <!-- Comments Header -->
                <div style="padding:10px 15px; border-bottom:1px solid #ddd; background:#fff;">
                    <strong style="font-size:14px;">Comments</strong>
                </div>

                <!-- Comments List -->
                <div id="commentsList" style="flex:1; overflow-y:auto; padding:10px;">
                    <div style="text-align:center; color:#999; padding:20px;">No comments yet. Be the first!</div>
                </div>

                <!-- Add Comment Input -->
                <div id="commentInputSection"
                    style="padding:10px; border-top:1px solid #ddd; background:#f9f9f9; display:none;">
                    <textarea id="newCommentText" placeholder="Write a comment..."
                        style="width:100%; height:60px; border:1px solid #ccc; border-radius:4px; padding:8px; font-family:Arial; font-size:13px; box-sizing:border-box; margin-bottom:8px;"></textarea>
                    <div style="display:flex; justify-content:flex-end; gap:5px;">
                        <button onclick="cancelComment()"
                            style="padding:6px 12px; background:#ccc; border:none; border-radius:4px; cursor:pointer; font-size:12px;">Cancel</button>
                        <button onclick="submitComment()"
                            style="padding:6px 12px; background:#673ab7; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:bold; font-size:12px;">Post</button>
                    </div>
                </div>

                <!-- Add Comment Button (shown when not typing) -->
                <div id="addCommentBtn" style="padding:10px; border-top:1px solid #ddd; background:#f9f9f9;">
                    <button onclick="showCommentInput()"
                        style="width:100%; padding:10px; background:#673ab7; color:white; border:none; border-radius:4px; cursor:pointer; font-weight:bold;">Add
                        Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="vault-modal" style="border-color: #ff9800;">
        <h3 style="margin-top:0; color:#ff9800;">Share Quest to Community</h3>
        <label style="font-size:12px; font-weight:bold;">Quest Name:</label>
        <input type="text" id="shareName" class="auth-input" placeholder="Enter a catchy title...">

        <label style="font-size:12px; font-weight:bold;">Description:</label>
        <textarea id="shareDesc" class="auth-input" style="height:80px; font-family:Arial;"
            placeholder="Briefly describe the objective, flavor text, or special rules..."></textarea>

        <div style="font-size:11px; color:#666; margin-bottom:10px;">
            * Allows other users to download and rate your quest.
        </div>

        <label style="font-size:12px; font-weight:bold;">Tags (comma separated):</label>
        <input type="text" id="shareTags" class="auth-input" placeholder="Dungeon, Crawl, Heroquest...">

        <button class="auth-btn" style="background:#ff9800;" onclick="confirmShare()">Publish to Community</button>
        <button onclick="toggleShareModal()"
            style="width:100%; margin-top:5px; background:#ccc; border:none; padding:8px; cursor:pointer;">Cancel</button>
    </div>

    <!-- Custom Save Layout Modal -->
    <div id="saveLayoutModal" class="vault-modal" style="border-color: #4CAF50;">
        <h3 style="margin-top:0; color:#4CAF50;">Save to Local Vault</h3>
        <label style="font-size:12px; font-weight:bold;">Layout Name:</label>
        <input type="text" id="saveLayoutName" class="auth-input" placeholder="e.g. My Awesome Dungeon">
        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:15px;">
            <button onclick="toggleSaveModal()"
                style="background:#555; color:white; border:none; padding:8px 15px; cursor:pointer;">Cancel</button>
            <button onclick="confirmSaveLayout()"
                style="background:#4CAF50; color:white; border:none; padding:8px 15px; cursor:pointer; font-weight:bold;">Save</button>
        </div>
    </div>

    <!-- Custom Alert Modal -->
    <div id="alertModal" class="vault-modal" style="border-color: #333; width: 300px; text-align:center;">
        <h3 id="alertTitle" style="margin-top:0; color:#333;">Alert</h3>
        <p id="alertMessage">Message goes here</p>
        <button onclick="closeCustomAlert()"
            style="background:#333; color:white; border:none; padding:8px 20px; cursor:pointer;">OK</button>
    </div>

    <!-- Confirm Modal for Delete -->
    <div id="confirmModal" class="vault-modal" style="border-color: #f44336; width: 400px;">
        <h3 id="confirmTitle" style="margin-top:0; color:#f44336;">Confirm Deletion</h3>
        <p id="confirmMessage" style="text-align:center; margin:20px 0;">Are you sure?</p>
        <div style="display:flex; justify-content:center; gap:10px; margin-top:20px;">
            <button id="confirmCancelBtn" onclick="closeConfirmModal()"
                style="background:#ccc; color:#333; border:none; padding:10px 20px; cursor:pointer; border-radius:4px; font-weight:bold;">Cancel</button>
            <button id="confirmOkBtn"
                style="background:#f44336; color:white; border:none; padding:10px 20px; cursor:pointer; border-radius:4px; font-weight:bold;">Delete</button>
        </div>
    </div>

    <!-- Room Notes Modal -->
    <div id="roomNotesModal" class="vault-modal" style="border-color: #E91E63;">
        <h3 style="margin-top:0; color:#E91E63;">Room Notes & Flavor Text</h3>
        <div id="roomNotesList" style="max-height:300px; overflow-y:auto; margin-bottom:10px;">
            <!-- Populated via JS -->
        </div>
        <button class="auth-btn" style="background:#E91E63;" onclick="saveRoomNotes()">Save Notes</button>
        <button onclick="toggleRoomNotes()"
            style="width:100%; margin-top:5px; background:#ccc; border:none; padding:8px; cursor:pointer;">Close</button>
    </div>

    <div id="wanderingMonster"></div>
    <!-- Auth Modal -->
    <div id="authModal" class="auth-modal">
        <h2 id="authTitle" style="text-align:center; color:#b22222; margin-top:0;">Login</h2>
        <div id="authError" style="color: red; font-size: 12px; text-align: center; margin-bottom: 5px; display: none;">
        </div>
        <input type="email" id="authEmail" class="auth-input" placeholder="Email Address">
        <input type="password" id="authPassword" class="auth-input" placeholder="Password">
        <input type="text" id="authDisplayName" class="auth-input" placeholder="Display Name (Public)"
            style="display:none;">
        <button id="authActionBtn" class="auth-btn" onclick="handleAuth()">Login</button>
        <div id="authSwitchBtn" class="auth-switch" onclick="toggleAuthMode()">Don't have an account? Register</div>
        <button onclick="toggleAuthModal()"
            style="margin-top:10px; width:100%; background:#ccc; color:black; border:none; padding:8px; border-radius:4px; cursor:pointer;">Cancel</button>
    </div>

    <!-- Profile Modal -->
    <div id="profileModal" class="vault-modal">
        <h3 style="margin-top:0; color:#333;">My Profile</h3>
        <div style="text-align:center; margin-bottom:15px;">
            <img id="profileAvatar"
                src="https://static.wixstatic.com/media/b16479_21439d3da9d7498dac057e020504ced2~mv2.png"
                style="width:80px; height:80px; border-radius:50%; object-fit:cover; border:2px solid #555;">
            <br>
            <button style="margin-top:5px; font-size:11px; padding:4px; cursor:pointer;" onclick="promptAvatar()">Change
                Avatar</button>
        </div>
        <label style="font-size:12px; font-weight:bold;">Display Name:</label>
        <input type="text" id="profileName" class="auth-input">

        <label style="font-size:12px; font-weight:bold;">Bio:</label>
        <textarea id="profileBio" class="auth-input" style="height:60px; font-family:Arial;"></textarea>

        <button class="auth-btn" onclick="saveProfile()">Save Profile</button>
        <button onclick="auth.signOut(); toggleProfileModal();"
            style="width:100%; margin-top:10px; background:#f44336; color:white; border:none; padding:10px; cursor:pointer; border-radius:4px; font-weight:bold;">Sign
            Out</button>
        <button onclick="toggleProfileModal()"
            style="width:100%; margin-top:10px; background:#ccc; border:none; padding:8px; cursor:pointer; border-radius:4px;">Close</button>
    </div>
    <div id="assetLibrary" class="side-panel right" style="display:none;">
        <h3 style="margin:0 0 10px 0; color:#673ab7;">Asset Library</h3>
        <div id="monsterAssets">
            <h4>Monsters</h4>
        </div>
        <div id="furnitureAssets">
            <h4>Furniture</h4>
        </div>
        <div id="wallAssets">
            <h4>Walls</h4>
        </div>
        <div id="trapAssets">
            <h4>Traps</h4>
        </div>
        <div id="doorAssets">
            <h4>Doors</h4>
        </div>
    </div>
	
	<!-- Wandering Monster Picker Modal -->
<div id="wmModal" class="vault-modal" style="width: 500px; max-height:80vh;">
    <h3 style="margin-top:0; color:#673ab7;">Select Wandering Monster</h3>
    <div id="wmGrid" style="display:grid; grid-template-columns: repeat(5, 1fr); gap:10px; padding:10px; max-height:400px; overflow-y:auto;">
        <!-- Filled by JS -->
    </div>
    <button onclick="document.getElementById('wmModal').style.display='none'; document.getElementById('overlay').style.display='none';" 
        style="width:100%; margin-top:10px; background:#ccc; border:none; padding:8px; cursor:pointer;">Cancel</button>
</div>

    <script>
        window.onerror = function (message, source, lineno, colno, error) {
            document.body.innerHTML = '<div style="background:red; color:white; padding:20px; font-size:24px; z-index:9999; position:fixed; top:0; left:0; width:100%;">' +
                'ERROR: ' + message + '<br>' +
                'Line: ' + lineno + '<br>' +
                'Col: ' + colno + '<br>' +
                'Stack: ' + (error ? error.stack : 'N/A') +
                '</div>';
            return false;
        };
    </script>
    <script>
        // --- FIREBASE CONFIGURATION ---
        const firebaseConfig = {
            apiKey: "AIzaSyCzzK7qB8aB4OajS0gGBqKEqlwVBpNdXNY",
            authDomain: "questgenerator-48a7b.firebaseapp.com",
            databaseURL: "https://questgenerator-48a7b-default-rtdb.firebaseio.com",
            projectId: "questgenerator-48a7b",
            storageBucket: "questgenerator-48a7b.firebasestorage.app",
            messagingSenderId: "663091262316",
            appId: "1:663091262316:web:6df9c249959dc3071cb949",
            measurementId: "G-MD26QTVGHN"
        };

        // Initialize Firebase
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        const auth = firebase.auth();
        const database = firebase.database();

        // Global User State
        let currentUser = null;

        // --- CONSTANTS & SIZES ---
        const CANVAS_WIDTH = 988;
        const CANVAS_HEIGHT = 760;
        const GRID_WIDTH = 26;
        const GRID_HEIGHT = 19;
        const SPACE_WIDTH = 38;
        const SPACE_HEIGHT = 40;
        const FURNITURE_SCALE = 1;
        const MONSTER_SCALE = 1.0;
        const TRAP_SIZE = 1;
        const DOOR_IMAGE_WIDTH = 38;
        const DOOR_IMAGE_HEIGHT = 20;

        // These were missing in your file!
        const WEAPONS_RACK_SIZE = { width: 1, height: 3 };
        const TOMB_SIZE = { width: 2, height: 3 };
        const ALCHEMY_TABLE_SIZE = { width: 2, height: 3 };
        const THRONE_SIZE = { width: 1, height: 1 };
        const TABLE_SIZE = { width: 2, height: 3 };
        const STAIRCASE_SIZE = { width: 2, height: 2 };
        const SORCERER_TABLE_SIZE = { width: 2, height: 3 };
        const TORTURE_RACK_SIZE = { width: 2, height: 3 };
        const FIREPLACE_SIZE = { width: 1, height: 3 };
        const CUPBOARD_SIZE = { width: 1, height: 3 };
        const BOOKSHELF_SIZE = { width: 1, height: 3 };
        const TREASURE_CHEST_SIZE = { width: 1, height: 1 };

        const MAX_FURNITURE = 12;
        const MAX_SECRET_DOORS = 5;
        const MAX_TRAPS = 10;

        let ROOM_COLOR = 'rgba(180, 180, 180, 0.85)';
        let CORRIDOR_COLOR = 'rgba(255, 255, 255, 0.85)';
        let INACTIVE_COLOR = 'rgba(60, 60, 60, 0.8)';
        let roomInstanceCounter = 0;
		let placedTexts = [];
		let editingTextItem = null; // The text object currently being edited
		let resizeHandle = null; // 'tl', 'tr', 'bl', 'br', 'rot' (rotation)
        const WALL_COLOR = '#000000';
        const DOOR_COLOR = '#8B4513';
        const SECRET_DOOR_COLOR = '#666666';
        const TRAP_COLOR = '#ff0000';
        const ROOM_NUMBER_COLOR = '#000000';
        const ROOM_NUMBER_FONT = '12px Arial';

        // --- ENGINE VARIABLES (Moved to top to prevent "Initialization" error) ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let isEditMode = false;
        let useCustomLayout = false;
        let customGrid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
        let selectedBrush = { type: 'room', w: 2, h: 2, rot: 0 };
        let mousePos = { x: 0, y: 0 };
        let isQuestEditMode = false;
        let draggedItem = null; // Stores object being moved
        let dragOffset = { x: 0, y: 0 };
        let draggedItemType = null;

        let grid = [];
        let currentQuest = null;
        let activeRooms = [];
        let doors = [];
        let roomNumberPositions = [];
        let placedFurniture = [];
        let placedMonsters = [];
        let placedWalls = [];
        let manualWalls = [];
        let placedTraps = [];
        let imageCache = {};

        // Play Mode State
        let playMode = false;
        let players = [];
        let selectedPlayer = null;
        let revealedTiles = new Set();
        let revealedRooms = new Set();
        let trapRevealedRooms = new Set();
        const PLAYER_COLORS = ['red', 'green', 'blue', 'brown'];
        const PLAYER_SIZE = SPACE_WIDTH * 0.8;

        // --- DATA ARRAYS ---

        const FURNITURE_IMAGES = {
            'Weapons Rack': 'https://static.wixstatic.com/media/b16479_891468c08b674ab3afee4e03d5e5a999~mv2.png',
            'Tomb': 'https://static.wixstatic.com/media/b16479_ef013aaffd074f48b8638f9a6348d094~mv2.png',
            'Alchemy Table': 'https://static.wixstatic.com/media/b16479_50122ecbf09e49af93f05b98fbdfb4fd~mv2.png',
            'Throne': 'https://static.wixstatic.com/media/b16479_7466db1627874870bbe17b71644f8dbc~mv2.png',
            'Table': 'https://static.wixstatic.com/media/b16479_b8e4765f2d434357a8a650e1fbc4474f~mv2.png',
            'Staircase': 'https://static.wixstatic.com/media/b16479_69dabca7ae12459c9edcf56a00bbe9ec~mv2.png',
            'Sorcerer Table': 'https://static.wixstatic.com/media/b16479_0612f445a4c1477e9f7da6571d184d51~mv2.png',
            'Torture Rack': 'https://static.wixstatic.com/media/b16479_555087929c34477e88ecc1033136f5e0~mv2.png',
            'Fireplace': 'https://static.wixstatic.com/media/b16479_ceb2a754590640a6b314f2cebcd1570e~mv2.png',
            'Cupboard': 'https://static.wixstatic.com/media/b16479_6f875d967877446a950ce0f37d03df46~mv2.png',
            'Bookshelf': 'https://static.wixstatic.com/media/b16479_c47cf8a3a4484084be8f842712f8f562~mv2.png',
            'Treasure Chest': 'https://static.wixstatic.com/media/b16479_0efba6dbf00d448e863f60bf78ff687d~mv2.png'
        };
        const WALL_IMAGES = {
            'Wall1x1': 'https://static.wixstatic.com/media/b16479_c924d0ba25f14227a6e4c218cf7c446b~mv2.png',
        };
        const DOOR_IMAGES = {
            'Door1x1': 'https://static.wixstatic.com/media/b16479_b07b52a35713453085b726a31a846447~mv2.png',
            'SecretDoor': 'https://static.wixstatic.com/media/b16479_e36647951bd845d9b6eb385e5fb562aa~mv2.png'
        };
        const MONSTER_IMAGES = {
            'Goblin': 'https://static.wixstatic.com/media/b16479_d0fa030b15484df5ae2e7fa2e542dc80~mv2.png',
            'Orc': 'https://static.wixstatic.com/media/b16479_e0265bd688b049308e39322a519b9ad2~mv2.png',
            'Skeleton': 'https://static.wixstatic.com/media/b16479_1961290a3f9c4987bcd8215e1e0fbf31~mv2.png',
            'Zombie': 'https://static.wixstatic.com/media/b16479_e108f496d9d84dc592f0c227a7dd206e~mv2.png',
            'Mummy': 'https://static.wixstatic.com/media/b16479_6095ff0e600b47b5bfe209f7746dbcba~mv2.png',
            'Chaos Warrior': 'https://static.wixstatic.com/media/b16479_b8877e7a86744a8abb93a8af47c1615f~mv2.png',
            'Fimir': 'https://static.wixstatic.com/media/b16479_af955c79936140cc8048e74b241221d5~mv2.png',
            'Gargoyle': 'https://static.wixstatic.com/media/b16479_0a4cd32570184467b4f1ce5aaa5406de~mv2.png',
            'Ice Gremlin': 'https://static.wixstatic.com/media/b16479_fb72e1a23a1e47f18e1fd4b64faba160~mv2.png',
            'Frozen Horror': 'https://static.wixstatic.com/media/b16479_f8ccf1eabf514a2499b926a2245a5400~mv2.png',
            'Venim': 'https://static.wixstatic.com/media/b16479_ad31e21c52554d3ebeaea8a24d8aaecf~mv2.png',
            'Chaos Sorcerer': 'https://static.wixstatic.com/media/b16479_15af8c4d3b15407eb744b5f9578ab70a~mv2.png',
            'Ogre Warrior': 'https://static.wixstatic.com/media/b16479_7a8f9cbe943f4804aef98994b8e454fd~mv2.png',
            'Skeleton Archer': 'https://static.wixstatic.com/media/b16479_bc73d258e66f461a9c212d23483d9fc6~mv2.png',
            'Orc Archer': 'https://static.wixstatic.com/media/b16479_da7ef411658547f184fb4bbe7309d5cf~mv2.png',
            'Ogre Lord': 'https://static.wixstatic.com/media/b16479_a0f03e6631004453bfe2b6fb0a7ca37c~mv2.png',
            'Ogre Chieftan': 'https://static.wixstatic.com/media/b16479_d3bbb7a8f77643cdaf70299ccba2a51f~mv2.png',
            'Goblin Slinger': 'https://static.wixstatic.com/media/b16479_444c580937f341c4bb50ba3061ec41b6~mv2.png',
            'Ogre Champion': 'https://static.wixstatic.com/media/b16479_5b4e2a6b027b4fdd84d48318ace73653~mv2.png',
            'Raptor': 'https://static.wixstatic.com/media/b16479_85b66b408a464b7b8b090a08d2dda5f4~mv2.png',
            'Serpent': 'https://static.wixstatic.com/media/b16479_4ead498418e348099eed25d42d396fa0~mv2.png',
            'Goblin Warlock': 'https://static.wixstatic.com/media/b16479_1d85365101a04af3aab5884d4cbdf263~mv2.png',
            'Giant Ape': 'https://static.wixstatic.com/media/b16479_24cecaa2712c4330a666fe340d73c882~mv2.png',
            'Blight Weaver': 'https://static.wixstatic.com/media/b16479_666d9d7f93f14667810413ce28b94c32~mv2.png',
            'Blight Crawler': 'https://static.wixstatic.com/media/b16479_5d44ce869ab949f9b69eac081f686daa~mv2.png',
            'Scout': 'https://static.wixstatic.com/media/b16479_b5c4c6f96d8c455e9c4aecbd2c1f1ac6~mv2.png',
            'Polar Warbear': 'https://static.wixstatic.com/media/b16479_f232374b4cff496992e37021ecbcc41d~mv2.png',
            'Yeti': 'https://static.wixstatic.com/media/b16479_8aab9f7e4c804c76a301e63134575115~mv2.png',
            'Dragon': 'https://static.wixstatic.com/media/b16479_0ec9167b0dba41ea9b270c3830cd0ef2~mv2.png'
        };
        const TRAP_IMAGES = {
            'Pit Trap': 'https://static.wixstatic.com/media/b16479_4bc0a93586c4475f8dcc13d71d32a636~mv2.png',
            'Spear Trap': 'https://static.wixstatic.com/media/b16479_edc6b473adc14f93b57deddfddda1bd3~mv2.png',
            'Falling Rock Trap': 'https://static.wixstatic.com/media/b16479_1814408fe6364a2a8cb7170dee497026~mv2.png',
            'Grasping Vines': 'https://static.wixstatic.com/media/b16479_a5d52e876020416198b0e8fb30ea1c8b~mv2.png',
            'Pit of Darkness': 'https://static.wixstatic.com/media/b16479_9e56d1f8a8264ef1b52e4c625992be71~mv2.png'
        };

        const furnitureTypes = [
            { name: 'Weapons Rack', size: WEAPONS_RACK_SIZE, imageUrl: FURNITURE_IMAGES['Weapons Rack'], hasFront: true },
            { name: 'Tomb', size: TOMB_SIZE, imageUrl: FURNITURE_IMAGES['Tomb'], hasFront: false },
            { name: 'Alchemy Table', size: ALCHEMY_TABLE_SIZE, imageUrl: FURNITURE_IMAGES['Alchemy Table'], hasFront: true },
            { name: 'Throne', size: THRONE_SIZE, imageUrl: FURNITURE_IMAGES['Throne'], hasFront: true },
            { name: 'Table', size: TABLE_SIZE, imageUrl: FURNITURE_IMAGES['Table'], hasFront: false },
            { name: 'Staircase', size: STAIRCASE_SIZE, imageUrl: FURNITURE_IMAGES['Staircase'], hasFront: true },
            { name: 'Sorcerer Table', size: SORCERER_TABLE_SIZE, imageUrl: FURNITURE_IMAGES['Sorcerer Table'], hasFront: true },
            { name: 'Torture Rack', size: TORTURE_RACK_SIZE, imageUrl: FURNITURE_IMAGES['Torture Rack'], hasFront: true },
            { name: 'Fireplace', size: FIREPLACE_SIZE, imageUrl: FURNITURE_IMAGES['Fireplace'], hasFront: true },
            { name: 'Cupboard', size: CUPBOARD_SIZE, imageUrl: FURNITURE_IMAGES['Cupboard'], hasFront: true },
            { name: 'Bookshelf', size: BOOKSHELF_SIZE, imageUrl: FURNITURE_IMAGES['Bookshelf'], hasFront: true },
            { name: 'Treasure Chest', size: TREASURE_CHEST_SIZE, imageUrl: FURNITURE_IMAGES['Treasure Chest'], hasFront: false }
        ];

        const wallTypes = [
            { name: 'Wall1x1', size: { width: 1, height: 1 }, imageUrl: WALL_IMAGES['Wall1x1'], hasFront: true }
        ];

        const trapTypes = [
            { name: 'Pit Trap', imageUrl: TRAP_IMAGES['Pit Trap'] },
            { name: 'Spear Trap', imageUrl: TRAP_IMAGES['Spear Trap'] },
            { name: 'Falling Rock Trap', imageUrl: TRAP_IMAGES['Falling Rock Trap'] }
        ];

        const doorTypes = [
            { name: 'Door1x1', size: { width: 1, height: 1 }, imageUrl: DOOR_IMAGES['Door1x1'], hasFront: true },
            { name: 'SecretDoor', size: { width: 1, height: 2 }, imageUrl: DOOR_IMAGES['SecretDoor'], hasFront: true }
        ];

        const SPACE_MAPPING = [
            { number: 1, type: 'A' }, { number: 2, type: 'A' }, { number: 3, type: 'A' }, { number: 4, type: 'A' }, { number: 5, type: 'A' }, { number: 6, type: 'A' }, { number: 7, type: 'A' }, { number: 8, type: 'A' }, { number: 9, type: 'A' }, { number: 10, type: 'A' }, { number: 11, type: 'A' }, { number: 12, type: 'A' }, { number: 13, type: 'A' }, { number: 14, type: 'A' }, { number: 15, type: 'A' }, { number: 16, type: 'A' }, { number: 17, type: 'A' }, { number: 18, type: 'A' }, { number: 19, type: 'A' }, { number: 20, type: 'A' }, { number: 21, type: 'A' }, { number: 22, type: 'A' }, { number: 23, type: 'A' }, { number: 24, type: 'A' }, { number: 25, type: 'A' }, { number: 26, type: 'A' },
            { number: 27, type: 'A' }, { number: 28, type: 'B' }, { number: 29, type: 'B' }, { number: 30, type: 'B' }, { number: 31, type: 'B' }, { number: 32, type: 'B' }, { number: 33, type: 'B' }, { number: 34, type: 'B' }, { number: 35, type: 'B' }, { number: 36, type: 'B' }, { number: 37, type: 'B' }, { number: 38, type: 'B' }, { number: 39, type: 'A' }, { number: 40, type: 'A' }, { number: 41, type: 'B' }, { number: 42, type: 'B' }, { number: 43, type: 'B' }, { number: 44, type: 'B' }, { number: 45, type: 'B' }, { number: 46, type: 'B' }, { number: 47, type: 'B' }, { number: 48, type: 'B' }, { number: 49, type: 'B' }, { number: 50, type: 'B' }, { number: 51, type: 'B' }, { number: 52, type: 'A' },
            { number: 53, type: 'A' }, { number: 54, type: 'B' }, { number: 55, type: 'B' }, { number: 56, type: 'B' }, { number: 57, type: 'B' }, { number: 58, type: 'B' }, { number: 59, type: 'B' }, { number: 60, type: 'B' }, { number: 61, type: 'B' }, { number: 62, type: 'B' }, { number: 63, type: 'B' }, { number: 64, type: 'B' }, { number: 65, type: 'A' }, { number: 66, type: 'A' }, { number: 67, type: 'B' }, { number: 68, type: 'B' }, { number: 69, type: 'B' }, { number: 70, type: 'B' }, { number: 71, type: 'B' }, { number: 72, type: 'B' }, { number: 73, type: 'B' }, { number: 74, type: 'B' }, { number: 75, type: 'B' }, { number: 76, type: 'B' }, { number: 77, type: 'B' }, { number: 78, type: 'A' },
            { number: 79, type: 'A' }, { number: 80, type: 'B' }, { number: 81, type: 'B' }, { number: 82, type: 'B' }, { number: 83, type: 'B' }, { number: 84, type: 'B' }, { number: 85, type: 'B' }, { number: 86, type: 'B' }, { number: 87, type: 'B' }, { number: 88, type: 'B' }, { number: 89, type: 'B' }, { number: 90, type: 'B' }, { number: 91, type: 'A' }, { number: 92, type: 'A' }, { number: 93, type: 'B' }, { number: 94, type: 'B' }, { number: 95, type: 'B' }, { number: 96, type: 'B' }, { number: 97, type: 'B' }, { number: 98, type: 'B' }, { number: 99, type: 'B' }, { number: 100, type: 'B' }, { number: 101, type: 'B' }, { number: 102, type: 'B' }, { number: 103, type: 'B' }, { number: 104, type: 'A' },
            { number: 105, type: 'A' }, { number: 106, type: 'B' }, { number: 107, type: 'B' }, { number: 108, type: 'B' }, { number: 109, type: 'B' }, { number: 110, type: 'B' }, { number: 111, type: 'B' }, { number: 112, type: 'B' }, { number: 113, type: 'B' }, { number: 114, type: 'B' }, { number: 115, type: 'B' }, { number: 116, type: 'B' }, { number: 117, type: 'A' }, { number: 118, type: 'A' }, { number: 119, type: 'B' }, { number: 120, type: 'B' }, { number: 121, type: 'B' }, { number: 122, type: 'B' }, { number: 123, type: 'B' }, { number: 124, type: 'B' }, { number: 125, type: 'B' }, { number: 126, type: 'B' }, { number: 127, type: 'B' }, { number: 128, type: 'B' }, { number: 129, type: 'B' }, { number: 130, type: 'A' },
            { number: 131, type: 'A' }, { number: 132, type: 'B' }, { number: 133, type: 'B' }, { number: 134, type: 'B' }, { number: 135, type: 'B' }, { number: 136, type: 'B' }, { number: 137, type: 'B' }, { number: 138, type: 'B' }, { number: 139, type: 'B' }, { number: 140, type: 'B' }, { number: 141, type: 'B' }, { number: 142, type: 'B' }, { number: 143, type: 'A' }, { number: 144, type: 'A' }, { number: 145, type: 'B' }, { number: 146, type: 'B' }, { number: 147, type: 'B' }, { number: 148, type: 'B' }, { number: 149, type: 'B' }, { number: 150, type: 'B' }, { number: 151, type: 'B' }, { number: 152, type: 'B' }, { number: 153, type: 'B' }, { number: 154, type: 'B' }, { number: 155, type: 'B' }, { number: 156, type: 'A' },
            { number: 157, type: 'A' }, { number: 158, type: 'B' }, { number: 159, type: 'B' }, { number: 160, type: 'B' }, { number: 161, type: 'B' }, { number: 162, type: 'B' }, { number: 163, type: 'B' }, { number: 164, type: 'B' }, { number: 165, type: 'B' }, { number: 166, type: 'A' }, { number: 167, type: 'A' }, { number: 168, type: 'A' }, { number: 169, type: 'A' }, { number: 170, type: 'A' }, { number: 171, type: 'A' }, { number: 172, type: 'A' }, { number: 173, type: 'A' }, { number: 174, type: 'B' }, { number: 175, type: 'B' }, { number: 176, type: 'B' }, { number: 177, type: 'B' }, { number: 178, type: 'B' }, { number: 179, type: 'B' }, { number: 180, type: 'B' }, { number: 181, type: 'B' }, { number: 182, type: 'A' },
            { number: 183, type: 'A' }, { number: 184, type: 'B' }, { number: 185, type: 'B' }, { number: 186, type: 'B' }, { number: 187, type: 'B' }, { number: 188, type: 'B' }, { number: 189, type: 'B' }, { number: 190, type: 'B' }, { number: 191, type: 'B' }, { number: 192, type: 'A' }, { number: 193, type: 'B' }, { number: 194, type: 'B' }, { number: 195, type: 'B' }, { number: 196, type: 'B' }, { number: 197, type: 'B' }, { number: 198, type: 'B' }, { number: 199, type: 'A' }, { number: 200, type: 'B' }, { number: 201, type: 'B' }, { number: 202, type: 'B' }, { number: 203, type: 'B' }, { number: 204, type: 'B' }, { number: 205, type: 'B' }, { number: 206, type: 'B' }, { number: 207, type: 'B' }, { number: 208, type: 'A' },
            { number: 209, type: 'A' }, { number: 210, type: 'B' }, { number: 211, type: 'B' }, { number: 212, type: 'B' }, { number: 213, type: 'B' }, { number: 214, type: 'B' }, { number: 215, type: 'B' }, { number: 216, type: 'B' }, { number: 217, type: 'B' }, { number: 218, type: 'A' }, { number: 219, type: 'B' }, { number: 220, type: 'B' }, { number: 221, type: 'B' }, { number: 222, type: 'B' }, { number: 223, type: 'B' }, { number: 224, type: 'B' }, { number: 225, type: 'A' }, { number: 226, type: 'B' }, { number: 227, type: 'B' }, { number: 228, type: 'B' }, { number: 229, type: 'B' }, { number: 230, type: 'B' }, { number: 231, type: 'B' }, { number: 232, type: 'B' }, { number: 233, type: 'B' }, { number: 234, type: 'A' },
            { number: 235, type: 'A' }, { number: 236, type: 'A' }, { number: 237, type: 'A' }, { number: 238, type: 'A' }, { number: 239, type: 'A' }, { number: 240, type: 'A' }, { number: 241, type: 'A' }, { number: 242, type: 'A' }, { number: 243, type: 'A' }, { number: 244, type: 'A' }, { number: 245, type: 'B' }, { number: 246, type: 'B' }, { number: 247, type: 'B' }, { number: 248, type: 'B' }, { number: 249, type: 'B' }, { number: 250, type: 'B' }, { number: 251, type: 'A' }, { number: 252, type: 'A' }, { number: 253, type: 'A' }, { number: 254, type: 'A' }, { number: 255, type: 'A' }, { number: 256, type: 'A' }, { number: 257, type: 'A' }, { number: 258, type: 'A' }, { number: 259, type: 'A' }, { number: 260, type: 'A' },
            { number: 261, type: 'A' }, { number: 262, type: 'B' }, { number: 263, type: 'B' }, { number: 264, type: 'B' }, { number: 265, type: 'B' }, { number: 266, type: 'B' }, { number: 267, type: 'B' }, { number: 268, type: 'B' }, { number: 269, type: 'B' }, { number: 270, type: 'A' }, { number: 271, type: 'B' }, { number: 272, type: 'B' }, { number: 273, type: 'B' }, { number: 274, type: 'B' }, { number: 275, type: 'B' }, { number: 276, type: 'B' }, { number: 277, type: 'A' }, { number: 278, type: 'B' }, { number: 279, type: 'B' }, { number: 280, type: 'B' }, { number: 281, type: 'B' }, { number: 282, type: 'B' }, { number: 283, type: 'B' }, { number: 284, type: 'B' }, { number: 285, type: 'B' }, { number: 286, type: 'A' },
            { number: 287, type: 'A' }, { number: 288, type: 'B' }, { number: 289, type: 'B' }, { number: 290, type: 'B' }, { number: 291, type: 'B' }, { number: 292, type: 'B' }, { number: 293, type: 'B' }, { number: 294, type: 'B' }, { number: 295, type: 'B' }, { number: 296, type: 'A' }, { number: 297, type: 'B' }, { number: 298, type: 'B' }, { number: 299, type: 'B' }, { number: 300, type: 'B' }, { number: 301, type: 'B' }, { number: 302, type: 'B' }, { number: 303, type: 'A' }, { number: 304, type: 'B' }, { number: 305, type: 'B' }, { number: 306, type: 'B' }, { number: 307, type: 'B' }, { number: 308, type: 'B' }, { number: 309, type: 'B' }, { number: 310, type: 'B' }, { number: 311, type: 'B' }, { number: 312, type: 'A' },
            { number: 313, type: 'A' }, { number: 314, type: 'B' }, { number: 315, type: 'B' }, { number: 316, type: 'B' }, { number: 317, type: 'B' }, { number: 318, type: 'B' }, { number: 319, type: 'B' }, { number: 320, type: 'B' }, { number: 321, type: 'B' }, { number: 322, type: 'A' }, { number: 323, type: 'A' }, { number: 324, type: 'A' }, { number: 325, type: 'A' }, { number: 326, type: 'A' }, { number: 327, type: 'A' }, { number: 328, type: 'A' }, { number: 329, type: 'A' }, { number: 330, type: 'B' }, { number: 331, type: 'B' }, { number: 332, type: 'B' }, { number: 333, type: 'B' }, { number: 334, type: 'B' }, { number: 335, type: 'B' }, { number: 336, type: 'B' }, { number: 337, type: 'B' }, { number: 338, type: 'A' },
            { number: 339, type: 'A' }, { number: 340, type: 'B' }, { number: 341, type: 'B' }, { number: 342, type: 'B' }, { number: 343, type: 'B' }, { number: 344, type: 'B' }, { number: 345, type: 'B' }, { number: 346, type: 'B' }, { number: 347, type: 'B' }, { number: 348, type: 'B' }, { number: 349, type: 'B' }, { number: 350, type: 'B' }, { number: 351, type: 'A' }, { number: 352, type: 'A' }, { number: 353, type: 'B' }, { number: 354, type: 'B' }, { number: 355, type: 'B' }, { number: 356, type: 'B' }, { number: 357, type: 'B' }, { number: 358, type: 'B' }, { number: 359, type: 'B' }, { number: 360, type: 'B' }, { number: 361, type: 'B' }, { number: 362, type: 'B' }, { number: 363, type: 'B' }, { number: 364, type: 'A' },
            { number: 365, type: 'A' }, { number: 366, type: 'B' }, { number: 367, type: 'B' }, { number: 368, type: 'B' }, { number: 369, type: 'B' }, { number: 370, type: 'B' }, { number: 371, type: 'B' }, { number: 372, type: 'B' }, { number: 373, type: 'B' }, { number: 374, type: 'B' }, { number: 375, type: 'B' }, { number: 376, type: 'B' }, { number: 377, type: 'A' }, { number: 378, type: 'A' }, { number: 379, type: 'B' }, { number: 380, type: 'B' }, { number: 381, type: 'B' }, { number: 382, type: 'B' }, { number: 383, type: 'B' }, { number: 384, type: 'B' }, { number: 385, type: 'B' }, { number: 386, type: 'B' }, { number: 387, type: 'B' }, { number: 388, type: 'B' }, { number: 389, type: 'B' }, { number: 390, type: 'A' },
            { number: 391, type: 'A' }, { number: 392, type: 'B' }, { number: 393, type: 'B' }, { number: 394, type: 'B' }, { number: 395, type: 'B' }, { number: 396, type: 'B' }, { number: 397, type: 'B' }, { number: 398, type: 'B' }, { number: 399, type: 'B' }, { number: 400, type: 'B' }, { number: 401, type: 'B' }, { number: 402, type: 'B' }, { number: 403, type: 'A' }, { number: 404, type: 'A' }, { number: 405, type: 'B' }, { number: 406, type: 'B' }, { number: 407, type: 'B' }, { number: 408, type: 'B' }, { number: 409, type: 'B' }, { number: 410, type: 'B' }, { number: 411, type: 'B' }, { number: 412, type: 'B' }, { number: 413, type: 'B' }, { number: 414, type: 'B' }, { number: 415, type: 'B' }, { number: 416, type: 'A' },
            { number: 417, type: 'A' }, { number: 418, type: 'B' }, { number: 419, type: 'B' }, { number: 420, type: 'B' }, { number: 421, type: 'B' }, { number: 422, type: 'B' }, { number: 423, type: 'B' }, { number: 424, type: 'B' }, { number: 425, type: 'B' }, { number: 426, type: 'B' }, { number: 427, type: 'B' }, { number: 428, type: 'B' }, { number: 429, type: 'A' }, { number: 430, type: 'A' }, { number: 431, type: 'B' }, { number: 432, type: 'B' }, { number: 433, type: 'B' }, { number: 434, type: 'B' }, { number: 435, type: 'B' }, { number: 436, type: 'B' }, { number: 437, type: 'B' }, { number: 438, type: 'B' }, { number: 439, type: 'B' }, { number: 440, type: 'B' }, { number: 441, type: 'B' }, { number: 442, type: 'A' },
            { number: 443, type: 'A' }, { number: 444, type: 'B' }, { number: 445, type: 'B' }, { number: 446, type: 'B' }, { number: 447, type: 'B' }, { number: 448, type: 'B' }, { number: 449, type: 'B' }, { number: 450, type: 'B' }, { number: 451, type: 'B' }, { number: 452, type: 'B' }, { number: 453, type: 'B' }, { number: 454, type: 'B' }, { number: 455, type: 'A' }, { number: 456, type: 'A' }, { number: 457, type: 'B' }, { number: 458, type: 'B' }, { number: 459, type: 'B' }, { number: 460, type: 'B' }, { number: 461, type: 'B' }, { number: 462, type: 'B' }, { number: 463, type: 'B' }, { number: 464, type: 'B' }, { number: 465, type: 'B' }, { number: 466, type: 'B' }, { number: 467, type: 'B' }, { number: 468, type: 'A' },
            { number: 469, type: 'A' }, { number: 470, type: 'A' }, { number: 471, type: 'A' }, { number: 472, type: 'A' }, { number: 473, type: 'A' }, { number: 474, type: 'A' }, { number: 475, type: 'A' }, { number: 476, type: 'A' }, { number: 477, type: 'A' }, { number: 478, type: 'A' }, { number: 479, type: 'A' }, { number: 480, type: 'A' }, { number: 481, type: 'A' }, { number: 482, type: 'A' }, { number: 483, type: 'A' }, { number: 484, type: 'A' }, { number: 485, type: 'A' }, { number: 486, type: 'A' }, { number: 487, type: 'A' }, { number: 488, type: 'A' }, { number: 489, type: 'A' }, { number: 490, type: 'A' }, { number: 491, type: 'A' }, { number: 492, type: 'A' }, { number: 493, type: 'A' }, { number: 494, type: 'A' }
        ];

        const ROOM_GROUPS = [
            { roomNumber: 1, spaces: [28, 29, 30, 31, 54, 55, 56, 57, 80, 81, 82, 83] },
            { roomNumber: 2, spaces: [32, 33, 34, 35, 58, 59, 60, 61, 84, 85, 86, 87] },
            { roomNumber: 3, spaces: [36, 37, 38, 62, 63, 64, 88, 89, 90, 114, 115, 116, 140, 141, 142] },
            { roomNumber: 4, spaces: [106, 107, 108, 109, 132, 133, 134, 135, 158, 159, 160, 161, 184, 185, 186, 187, 210, 211, 212, 213] },
            { roomNumber: 5, spaces: [110, 111, 112, 113, 136, 137, 138, 139, 162, 163, 164, 165, 188, 189, 190, 191, 214, 215, 216, 217] },
            { roomNumber: 6, spaces: [41, 42, 43, 67, 68, 69, 93, 94, 95, 119, 120, 121, 145, 146, 147] },
            { roomNumber: 7, spaces: [44, 45, 46, 47, 70, 71, 72, 73, 96, 97, 98, 99, 122, 123, 124, 125] },
            { roomNumber: 8, spaces: [48, 49, 50, 51, 74, 75, 76, 77, 100, 101, 102, 103, 126, 127, 128, 129] },
            { roomNumber: 9, spaces: [148, 149, 150, 151, 174, 175, 176, 177, 200, 201, 202, 203, 226, 227, 228, 229] },
            { roomNumber: 10, spaces: [152, 153, 154, 155, 178, 179, 180, 181, 204, 205, 206, 207, 230, 231, 232, 233] },
            { roomNumber: 11, spaces: [193, 194, 195, 196, 197, 198, 219, 220, 221, 222, 223, 224, 245, 246, 247, 248, 249, 250, 271, 272, 273, 274, 275, 276, 297, 298, 299, 300, 301, 302] },
            { roomNumber: 12, spaces: [262, 263, 264, 265, 288, 289, 290, 291, 314, 315, 316, 317, 340, 341, 342, 343] },
            { roomNumber: 13, spaces: [266, 267, 292, 293, 318, 319] },
            { roomNumber: 14, spaces: [268, 269, 294, 295, 320, 321] },
            { roomNumber: 15, spaces: [366, 367, 368, 369, 392, 393, 394, 395, 418, 419, 420, 421, 444, 445, 446, 447] },
            { roomNumber: 16, spaces: [344, 345, 346, 347, 370, 371, 372, 373, 396, 397, 398, 399, 422, 423, 424, 425, 448, 449, 450, 451] },
            { roomNumber: 17, spaces: [348, 349, 350, 374, 375, 376, 400, 401, 402, 426, 427, 428, 452, 453, 454] },
            { roomNumber: 18, spaces: [353, 354, 355, 356, 379, 380, 381, 382, 405, 406, 407, 408, 431, 432, 433, 434, 457, 458, 459, 460] },
            { roomNumber: 19, spaces: [278, 279, 280, 281, 304, 305, 306, 307, 330, 331, 332, 333, 357, 358, 359] },
            { number: 20, spaces: [282, 283, 284, 285, 308, 309, 310, 311, 334, 335, 336, 337, 360, 361, 362, 363] },
            { roomNumber: 21, spaces: [383, 384, 385, 409, 410, 411, 435, 436, 437, 461, 462, 463] },
            { roomNumber: 22, spaces: [386, 387, 388, 389, 412, 413, 414, 415, 438, 439, 440, 441, 464, 465, 466, 467] }
        ];

        const monsterTypes = [
            // --- STANDARD MONSTERS (1x1) ---
            { name: 'Goblin', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Goblin'] },
            { name: 'Orc', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Orc'] },
            { name: 'Skeleton', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Skeleton'] },
            { name: 'Zombie', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Zombie'] },
            { name: 'Mummy', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Mummy'] },
            { name: 'Chaos Warrior', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Chaos Warrior'] },
            { name: 'Fimir', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Fimir'] },
            { name: 'Gargoyle', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Gargoyle'] },
            { name: 'Goblin Slinger', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Goblin Slinger'] },
            { name: 'Orc Archer', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Orc Archer'] },
            { name: 'Skeleton Archer', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Skeleton Archer'] },
            { name: 'Chaos Sorcerer', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Chaos Sorcerer'] },
            { name: 'Venim', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Venim'] },
            { name: 'Ice Gremlin', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Ice Gremlin'] },
            { name: 'Scout', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Scout'] },
            { name: 'Blight Weaver', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Blight Weaver'] },
            { name: 'Goblin Warlock', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Goblin Warlock'] },
            { name: 'Raptor', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Raptor'] },

            // --- LARGE MONSTERS (2x1) ---
            { name: 'Ogre Lord', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Ogre Lord'] },
            { name: 'Ogre Chieftan', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Ogre Chieftan'] },
            { name: 'Ogre Champion', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Ogre Champion'] },
            { name: 'Ogre Warrior', size: { width: 1, height: 1 }, imageUrl: MONSTER_IMAGES['Ogre Warrior'] },
            { name: 'Polar Warbear', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Polar Warbear'] },
            { name: 'Yeti', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Yeti'] },
            { name: 'Serpent', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Serpent'] },
            { name: 'Blight Crawler', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Blight Crawler'] },
            { name: 'Dragon', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Dragon'] },
            { name: 'Giant Ape', size: { width: 2, height: 1 }, imageUrl: MONSTER_IMAGES['Giant Ape'] },

            // --- HUGE MONSTERS (2x2) ---
            { name: 'Frozen Horror', size: { width: 2, height: 2 }, imageUrl: MONSTER_IMAGES['Frozen Horror'] }
        ];

        const questObjectives = [
            { name: 'The Lost Library', objective: 'Retrieve the ancient tome from the Treasure Chest in Room C.', objectiveRoom: 'C', objectiveItem: 'Treasure Chest' },
            { name: 'The Alchemist‚Äôs Lab', objective: 'Destroy the Alchemy Table in Room C to end the chaos.', objectiveRoom: 'C', objectiveItem: 'Alchemy Table' },
            { name: 'The Throne of Shadows', objective: 'Defeat the Gargoyle in Room C to banish the shadowy presence.', objectiveRoom: 'C', objectiveItem: null },
            { name: 'The Haunted Crypt', objective: 'Destroy the Tomb in Room C to seal the crypt.', objectiveRoom: 'C', objectiveItem: 'Tomb' },
            { name: 'The Orcish Forge', objective: 'Destroy the Weapons Rack in Room C to sabotage the forge.', objectiveRoom: 'C', objectiveItem: 'Weapons Rack' },
            { name: 'The Sorcerer‚Äôs Tower', objective: 'Destroy the Sorcerer Table in Room C and/or D to dispel the wards.', objectiveRoom: 'D', objectiveItem: 'Sorcerer Table' },
            { name: 'The Goblin Tunnels', objective: 'Defeat all monsters in Room C to rescue the captives.', objectiveRoom: 'C', objectiveItem: null },
            { name: 'The Chaos Cult', objective: 'Defeat the Chaos Warrior in Room C to disrupt the ritual.', objectiveRoom: 'C', objectiveItem: null },
            { name: 'The Fimir Swamp', objective: 'Destroy the Treasure Chest in Room D to eradicate the Fimir nest.', objectiveRoom: 'D', objectiveItem: 'Treasure Chest' },
            { name: 'The Gargoyle‚Äôs Perch', objective: 'Retrieve the heartstone from the Treasure Chest in Room D.', objectiveRoom: 'D', objectiveItem: 'Treasure Chest' },

            // 10 Quests with 8 Rooms
            { name: 'The Shattered Reliquary', objective: 'Retrieve the Sacred Relic from the Treasure Chest in Room H.', objectiveRoom: 'H', objectiveItem: 'Treasure Chest' },
            { name: 'Crypt of the Betrayer', objective: 'Defeat the Chaos Warrior in Room H to end the curse.', objectiveRoom: 'H', objectiveItem: null },
            { name: 'The Forbidden Vault', objective: 'Destroy the Sorcerer Table in Room G to break the arcane seal.', objectiveRoom: 'G', objectiveItem: 'Sorcerer Table' },
            { name: 'Tomb of the Fallen King', objective: 'Retrieve the Crown of Ages from the Treasure Chest in Room H.', objectiveRoom: 'H', objectiveItem: 'Treasure Chest' },
            { name: 'The Iron Labyrinth', objective: 'Destroy the Weapons Rack in Room G to halt the war machine.', objectiveRoom: 'G', objectiveItem: 'Weapons Rack' },
            { name: 'Halls of the Forgotten', objective: 'Defeat all monsters in Room H to cleanse the halls.', objectiveRoom: 'H', objectiveItem: null },
            { name: 'The Cursed Altar', objective: 'Destroy the Table in Room F to disrupt the dark ritual.', objectiveRoom: 'F', objectiveItem: 'Table' },
            { name: 'Den of the Warlord', objective: 'Defeat the Fimir in Room H to seize control of the den.', objectiveRoom: 'H', objectiveItem: null },
            { name: 'The Abyssal Shrine', objective: 'Retrieve the Orb of Shadows from the Treasure Chest in Room G.', objectiveRoom: 'G', objectiveItem: 'Treasure Chest' },
            { name: 'The Wraith‚Äôs Dominion', objective: 'Destroy the Tomb in Room H to banish the wraith.', objectiveRoom: 'H', objectiveItem: 'Tomb' },

            // 10 Quests with 6 Rooms
            { name: 'Echoes of the Abyss', objective: 'Defeat the Gargoyle in Room F to silence the abyss.', objectiveRoom: 'F', objectiveItem: null },
            { name: 'The Blighted Forge', objective: 'Destroy the Weapons Rack in Room E to sabotage the forge.', objectiveRoom: 'E', objectiveItem: 'Weapons Rack' },
            { name: 'Tunnels of Despair', objective: 'Retrieve the Crystal Key from the Treasure Chest in Room F.', objectiveRoom: 'F', objectiveItem: 'Treasure Chest' },
            { name: 'The Necromancer‚Äôs Hold', objective: 'Destroy the Sorcerer Table in Room E to break the necromantic wards.', objectiveRoom: 'E', objectiveItem: 'Sorcerer Table' },
            { name: 'The Bloodied Throne', objective: 'Defeat all monsters in Room F to claim the throne.', objectiveRoom: 'F', objectiveItem: null },
            { name: 'Caverns of the Lost', objective: 'Retrieve the Amulet of Power from the Treasure Chest in Room E.', objectiveRoom: 'E', objectiveItem: 'Treasure Chest' },
            { name: 'The Shadow Maze', objective: 'Destroy the Table in Room F to dispel the maze‚Äôs illusion.', objectiveRoom: 'F', objectiveItem: 'Table' },
            { name: 'The Orcish Outpost', objective: 'Defeat the Orc in Room E to disrupt their plans.', objectiveRoom: 'E', objectiveItem: null },
            { name: 'The Ancient Sepulcher', objective: 'Destroy the Tomb in Room F to end the haunting.', objectiveRoom: 'F', objectiveItem: 'Tomb' },
            { name: 'The Chaos Sanctum', objective: 'Defeat the Chaos Warrior in Room E to halt the summoning.', objectiveRoom: 'E', objectiveItem: null },

            // 10 Quests with 5 Rooms
            { name: 'The Witch‚Äôs Lair', objective: 'Destroy the Sorcerer Table in Room E to break her spell.', objectiveRoom: 'E', objectiveItem: 'Sorcerer Table' },
            { name: 'The Goblin Warrens', objective: 'Defeat all Goblins in Room D to free the prisoners.', objectiveRoom: 'D', objectiveItem: null },
            { name: 'The Forgotten Armory', objective: 'Retrieve the Blade of Eternity from the Treasure Chest in Room E.', objectiveRoom: 'E', objectiveItem: 'Treasure Chest' },
            { name: 'The Cursed Catacombs', objective: 'Destroy the Tomb in Room D to lift the curse.', objectiveRoom: 'D', objectiveItem: 'Tomb' },
            { name: 'The Fimir‚Äôs Den', objective: 'Defeat the Fimir in Room E to destroy their lair.', objectiveRoom: 'E', objectiveItem: null },
            { name: 'The Dark Forge', objective: 'Destroy the Weapons Rack in Room D to stop the production.', objectiveRoom: 'D', objectiveItem: 'Weapons Rack' },
            { name: 'The Spectral Vault', objective: 'Retrieve the Ghostly Chalice from the Treasure Chest in Room E.', objectiveRoom: 'E', objectiveItem: 'Treasure Chest' },
            { name: 'The Chaos Spire', objective: 'Defeat the Chaos Warrior in Room D to end the ritual.', objectiveRoom: 'D', objectiveItem: null },
            { name: 'The Hidden Tomb', objective: 'Destroy the Tomb in Room E to seal the rift.', objectiveRoom: 'E', objectiveItem: 'Tomb' },
            { name: 'The Orcish Hold', objective: 'Defeat all Orcs in Room D to secure the hold.', objectiveRoom: 'D', objectiveItem: null },

            // 10 Quests with 3 or 4 Rooms
            { name: 'The Ghostly Passage', objective: 'Retrieve the Spirit Gem from the Treasure Chest in Room C.', objectiveRoom: 'C', objectiveItem: 'Treasure Chest', rooms: 3 },
            { name: 'The Skeleton Keep', objective: 'Defeat all Skeletons in Room C to cleanse the keep.', objectiveRoom: 'C', objectiveItem: null, rooms: 3 },
            { name: 'The Sorcerer‚Äôs Cell', objective: 'Destroy the Sorcerer Table in Room C to end the enchantment.', objectiveRoom: 'C', objectiveItem: 'Sorcerer Table', rooms: 3 },
            { name: 'The Goblin Hideout', objective: 'Defeat the Goblin in Room C to rescue the captive.', objectiveRoom: 'C', objectiveItem: null, rooms: 3 },
            { name: 'The Zombie Crypt', objective: 'Destroy the Tomb in Room C to stop the undead.', objectiveRoom: 'C', objectiveItem: 'Tomb', rooms: 3 },
            { name: 'The Chaos Vault', objective: 'Retrieve the Chaos Rune from the Treasure Chest in Room D.', objectiveRoom: 'D', objectiveItem: 'Treasure Chest', rooms: 4 },
            { name: 'The Fimir‚Äôs Lair', objective: 'Defeat the Fimir in Room D to end their reign.', objectiveRoom: 'D', objectiveItem: null, rooms: 4 },
            { name: 'The Cursed Armory', objective: 'Destroy the Weapons Rack in Room D to break the curse.', objectiveRoom: 'D', objectiveItem: 'Weapons Rack', rooms: 4 },
            { name: 'The Dark Library', objective: 'Retrieve the Tome of Shadows from the Treasure Chest in Room D.', objectiveRoom: 'D', objectiveItem: 'Treasure Chest', rooms: 4 },
            { name: 'The Mummy‚Äôs Tomb', objective: 'Destroy the Tomb in Room D to banish the mummy.', objectiveRoom: 'D', objectiveItem: 'Tomb', rooms: 4 }
        ];

        const quests = [
            {
                name: 'The Lost Library',
                flavor: 'Legends speak of a hidden library beneath the old citadel, its shelves brimming with forbidden knowledge sealed away by ancient scholars. Dust and shadows cloak the halls as the heroes descend to retrieve the ancient tome, a relic said to hold secrets of immense power.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Entrance Hall', flavor: 'Cobwebs drape ancient statues lining the walls, their stone eyes watching as dust swirls in the stale air.', furniture: [{ type: 'Bookshelf', count: 1 }, { type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }, { type: 'Zombie', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Study', flavor: 'A cluttered desk sits amidst scattered parchments, the remnants of some frantic research abandoned long ago.', furniture: [{ type: 'Table', count: 1 }, { type: 'Throne', count: 1 }, { type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }, { type: 'Orc', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Library', flavor: 'Towering shelves stretch into the gloom, packed with moldering tomes that whisper faintly as you pass.', furniture: [{ type: 'Bookshelf', count: 1 }, { type: 'Table', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }, { type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Secret Chamber', flavor: 'A concealed door reveals a small room, its arcane aura hinting at secrets known only to a select few.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Alchemist‚Äôs Lab',
                flavor: 'In a forgotten corner of the city, an alchemist‚Äôs experiment has spiraled out of control, spawning twisted abominations that stalk the shadows. The heroes must breach the lab‚Äôs defenses to destroy the apparatus fueling this chaos.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Equipment card',
                rooms: [
                    { letter: 'A', name: 'Workshop', flavor: 'Tools and half-finished contraptions clutter the workbenches, the air heavy with the scent of molten metal.', furniture: [{ type: 'Table', count: 1 }, { type: 'Cupboard', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }, { type: 'Orc', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Storage Room', flavor: 'Shelves groan under jars of strange fluids and powders, some glowing faintly in the dim light.', furniture: [{ type: 'Cupboard', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }, { type: 'Skeleton', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Laboratory', flavor: 'Bubbling vats and sparking devices fill the room, centered around a massive apparatus pulsing with dark energy.', furniture: [{ type: 'Alchemy Table', count: 1 }, { type: 'Sorcerer Table', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Alchemist‚Äôs Quarters', flavor: 'A modest bed and scattered notes suggest the alchemist fled in haste, leaving treasures behind.', furniture: [{ type: 'Table', count: 1 }, { type: 'Bookshelf', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }, { type: 'Goblin', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Throne of Shadows',
                flavor: 'A malevolent entity has claimed the ancient throne room of a fallen kingdom, its shadow seeping into the stone. The heroes must confront this dark presence to break its hold over the land.',
                rewards: 'Draw 1 Treasure card, Draw 2 Artifact cards',
                rooms: [
                    { letter: 'A', name: 'Antechamber', flavor: 'Faded tapestries of forgotten battles flutter in a cold breeze that seems to come from nowhere.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }, { type: 'Zombie', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Guard Room', flavor: 'Rusty armor stands in silent vigil, a testament to the keep‚Äôs lost defenders.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }, { type: 'Goblin', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Throne Room', flavor: 'A grand throne looms on a dais, its surface cloaked in unnatural darkness that writhes like smoke.', furniture: [{ type: 'Throne', count: 1 }, { type: 'Table', count: 1 }, { type: 'Fireplace', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Chaos Warrior', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Dungeon', flavor: 'The damp air echoes with the drip of water, mingling with the clank of ancient chains.', furniture: [{ type: 'Torture Rack', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }, { type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] }
                ]
            },
            {
                name: 'The Haunted Crypt',
                flavor: 'An ancient crypt lies disturbed beneath the moors, its restless dead spilling forth under a necromancer‚Äôs command. The heroes must enter its depths to destroy the source of this unholy awakening.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Crypt Entrance', flavor: 'A heavy stone door grinds open, revealing a staircase descending into shadow-haunted silence.', furniture: [{ type: 'Staircase', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }, { type: 'Zombie', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Catacombs', flavor: 'Narrow passages twist between burial niches, the air thick with the dust of centuries.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }, { type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Burial Chamber', flavor: 'A massive sarcophagus glows with an eerie light, its lid scratched by clawing hands from within.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Zombie', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Ritual Room', flavor: 'Faint chants linger in the air, etched symbols pulsing on the floor from some dark ceremony.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Orc', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Orcish Forge',
                flavor: 'Deep within a volcanic cavern, orcs labor tirelessly to forge weapons for their warlord‚Äôs campaign. The heroes must infiltrate this fiery stronghold to sabotage their efforts and stem the tide of war.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Forge Entrance', flavor: 'The heat of molten metal sears the air as the clang of hammers echoes from within.', furniture: [{ type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Orc', count: 2 }, { type: 'Goblin', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Smithy', flavor: 'Anvils glow red-hot, surrounded by orcs hammering crude blades into shape.', furniture: [{ type: 'Table', count: 1 }, { type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }, { type: 'Fimir', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Armory', flavor: 'Racks of jagged swords and axes gleam menacingly, freshly forged for battle.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Orc Barracks', flavor: 'Crude bunks and scattered loot mark the resting place of the forge‚Äôs brutish workers.', furniture: [{ type: 'Table', count: 1 }, { type: 'Cupboard', count: 1 }], monsters: [{ type: 'Orc', count: 3 }, { type: 'Goblin', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Sorcerer‚Äôs Tower',
                flavor: 'A towering spire rises from the mist, its peak wreathed in arcane wards cast by a reclusive sorcerer. The heroes must ascend its perilous heights to dispel the magic protecting his sanctum.',
                rewards: 'Draw 1 Treasure card, Draw 2 Artifact cards',
                rooms: [
                    { letter: 'A', name: 'Tower Base', flavor: 'The ground floor hums with arcane trinkets, their faint glow illuminating a spiral stair.', furniture: [{ type: 'Table', count: 1 }, { type: 'Bookshelf', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }, { type: 'Goblin', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Arcane Workshop', flavor: 'Workbenches are strewn with mystical components, their energies crackling faintly.', furniture: [{ type: 'Alchemy Table', count: 1 }, { type: 'Sorcerer Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }, { type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Summoning Chamber', flavor: 'A pentagram etched in blood pulses on the floor, a gateway to otherworldly horrors.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Sorcerer‚Äôs Sanctum', flavor: 'The air shimmers with protective wards, guarding the sorcerer‚Äôs throne and treasures.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Throne', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Chaos Warrior', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Goblin Tunnels',
                flavor: 'Beneath the hills, goblins have carved a warren of tunnels to hold their captives, plundered from nearby villages. The heroes must brave the cramped passages to rescue those trapped within.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Potion card',
                rooms: [
                    { letter: 'A', name: 'Tunnel Entrance', flavor: 'A jagged hole in the hillside opens into a dark, winding passage reeking of goblin filth.', furniture: [{ type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 3 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Goblin Den', flavor: 'A squalid chamber filled with gnawed bones and stolen trinkets, the goblins‚Äô crude home.', furniture: [{ type: 'Table', count: 1 }, { type: 'Cupboard', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }, { type: 'Orc', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Prison', flavor: 'Rough-hewn bars cage terrified villagers, their pleas echoing off the damp stone walls.', furniture: [{ type: 'Torture Rack', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 1 }, { type: 'Goblin', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Treasure Room', flavor: 'The goblins‚Äô hoard glitters faintly, piled high with loot from countless raids.', furniture: [{ type: 'Treasure Chest', count: 2 }, { type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }, { type: 'Goblin', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Chaos Cult',
                flavor: 'A fanatical cult has taken root in an abandoned manor, their chants summoning chaos to tear the world asunder. The heroes must storm their lair to halt the ritual before it‚Äôs too late.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Cult Hideout', flavor: 'Unholy symbols scar the walls, the air thick with incense and whispered prayers.', furniture: [{ type: 'Table', count: 1 }, { type: 'Bookshelf', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }, { type: 'Orc', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Altar Room', flavor: 'A blood-stained altar stands at the room‚Äôs heart, its surface etched with runes of power.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }, { type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Sacrificial Chamber', flavor: 'The floor is slick with offerings, the cult‚Äôs dark rites nearing their climax.', furniture: [{ type: 'Throne', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Zombie', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Cult Leader‚Äôs Quarters', flavor: 'Ornate relics adorn the room, the cult leader‚Äôs sanctuary of twisted faith.', furniture: [{ type: 'Table', count: 1 }, { type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Fimir Swamp',
                flavor: 'A noxious swamp festers with the presence of the Fimir, their grotesque forms lurking in the mire. The heroes must wade through this wretched place to destroy their nest and end their terror.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Potion card',
                rooms: [
                    { letter: 'A', name: 'Swamp Path', flavor: 'Muddy trails twist through dense, stinking foliage, the ground sucking at every step.', furniture: [{ type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }, { type: 'Orc', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Bog', flavor: 'The air hums with insects as the soft earth shifts, concealing dangers beneath its surface.', furniture: [], monsters: [{ type: 'Fimir', count: 1 }, { type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Fimir Lair', flavor: 'A damp cavern reeks of rot, the Fimir‚Äôs crude dwelling carved into the swamp‚Äôs heart.', furniture: [{ type: 'Table', count: 1 }, { type: 'Cupboard', count: 1 }], monsters: [{ type: 'Fimir', count: 2 }, { type: 'Goblin', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Nest Chamber', flavor: 'The Fimir‚Äôs brood writhes within a foul nest, its destruction key to cleansing this land.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Fimir', count: 3 }], traps: [] }
                ]
            },
            {
                name: 'The Gargoyle‚Äôs Perch',
                flavor: 'Atop jagged peaks, a gargoyle guards a mystical heartstone, its stone wings casting long shadows over the cliffs. The heroes must scale this perilous roost to claim the prize.',
                rewards: 'Draw 1 Treasure card, Draw 2 Artifact cards',
                rooms: [
                    { letter: 'A', name: 'Mountain Path', flavor: 'A narrow trail winds up the mountainside, loose rocks clattering underfoot.', furniture: [{ type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }, { type: 'Goblin', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Cave Entrance', flavor: 'A dark maw yawns in the cliff face, its depths echoing with the wind‚Äôs mournful howl.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }, { type: 'Zombie', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Gargoyle Nest', flavor: 'Stone perches jut from the walls, shadowed by the flapping of leathery wings.', furniture: [{ type: 'Throne', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Heartstone Chamber', flavor: 'A radiant gem pulses within a chest, its light bathing the room in an unearthly glow.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Sorcerer Table', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            // 10 Quests with 8 Rooms
            {
                name: 'The Shattered Reliquary',
                flavor: 'Deep within a crumbling cathedral, a sacred relic lies hidden, guarded by fanatical cultists and their monstrous allies. The heroes must navigate a maze of collapsing halls to retrieve it before the cult unleashes its power.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Ruined Vestibule', flavor: 'Broken stained glass crunches underfoot as shadows flicker in the dim light.', furniture: [{ type: 'Table', count: 1 }, { type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Cloister Walk', flavor: 'Vines choke the ancient stone arches, whispering of forgotten prayers.', furniture: [{ type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Chancel', flavor: 'A defiled altar looms, stained with offerings to dark powers.', furniture: [{ type: 'Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Crypt Passage', flavor: 'Cold air seeps from cracked tombs, the silence broken by distant moans.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'E', name: 'Sacristy', flavor: 'Sacred vestments lie in tatters, replaced by profane relics of chaos.', furniture: [{ type: 'Cupboard', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'F', name: 'Nave', flavor: 'Pews lie shattered, the air thick with the stench of corruption.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Goblin', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'G', name: 'Relic Chamber', flavor: 'A faint holy glow pulses from a sealed vault, warded by dark magic.', furniture: [{ type: 'Sorcerer Table', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'H', name: 'Sanctum', flavor: 'The relic rests on a pedestal, surrounded by cultists chanting in unholy fervor.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'Crypt of the Betrayer',
                flavor: 'A traitor knight‚Äôs tomb has been desecrated, his spirit now commanding an army of the dead. The heroes must descend into the crypt to defeat his lingering will and end the curse.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Mausoleum Gate', flavor: 'Rusted iron gates groan as the wind carries whispers of betrayal.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Burial Corridor', flavor: 'Flickering torches cast eerie shadows on cracked stone walls.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ossuary', flavor: 'Piles of bones shift unnaturally, as if stirred by an unseen hand.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 3 }], traps: [] },
                    { letter: 'D', name: 'Chapel of Sorrow', flavor: 'A shattered altar weeps black ichor, defiled by dark rites.', furniture: [{ type: 'Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Knight‚Äôs Tomb', flavor: 'The traitor‚Äôs sarcophagus pulses with malevolent energy.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Ritual Chamber', flavor: 'Runes glow on the floor, fueling the knight‚Äôs cursed spirit.', furniture: [{ type: 'Sorcerer Table', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'G', name: 'Guardroom', flavor: 'Ancient armor stands watch, animated by the betrayer‚Äôs will.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'H', name: 'Betrayer‚Äôs Sanctum', flavor: 'The knight‚Äôs spirit lingers, commanding his undead legion.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 2 }, { type: 'Skeleton', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Forbidden Vault',
                flavor: 'A sealed vault holds a forbidden artifact, its power threatening to unravel reality. The heroes must breach its defenses and destroy the sorcerous wards protecting it.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Outer Gate', flavor: 'Runes pulse on massive stone doors, warding off intruders.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Guard Post', flavor: 'Crude barricades suggest recent orcish occupation.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Arcane Hall', flavor: 'Glowing sigils line the walls, humming with arcane power.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Vault Antechamber', flavor: 'The air crackles with energy, the vault‚Äôs wards growing stronger.', furniture: [{ type: 'Sorcerer Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Trap Corridor', flavor: 'The floor is littered with the bones of failed intruders.', furniture: [], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Pit Trap', count: 2 }] },
                    { letter: 'F', name: 'Ward Room', flavor: 'A complex array of runes guards the vault‚Äôs entrance.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'G', name: 'Sorcerer‚Äôs Sanctum', flavor: 'The source of the vault‚Äôs wards lies here, pulsing with dark magic.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'H', name: 'Vault Core', flavor: 'The artifact hums within, its power barely contained.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'Tomb of the Fallen King',
                flavor: 'A long-dead king‚Äôs tomb has been disturbed, his crown now a beacon for dark forces. The heroes must retrieve the crown to restore peace to the realm.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Equipment card',
                rooms: [
                    { letter: 'A', name: 'Royal Mausoleum', flavor: 'Marble statues of past kings stand in silent judgment.', furniture: [{ type: 'Staircase', count: 1 }, { type: 'Tomb', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Guard Chamber', flavor: 'Rusty halberds line the walls, once wielded by loyal knights.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Burial Hall', flavor: 'Ornate coffins lie in rows, their lids cracked by unseen hands.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Throne Room', flavor: 'A ghostly throne sits empty, its occupant long departed.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Royal Treasury', flavor: 'Gold glints in the shadows, guarded by restless spirits.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'F', name: 'Crypt Passage', flavor: 'The air grows colder, the king‚Äôs presence lingering.', furniture: [], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'G', name: 'King‚Äôs Antechamber', flavor: 'Ancient runes glow faintly, protecting the king‚Äôs resting place.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'H', name: 'King‚Äôs Tomb', flavor: 'The crown rests within a sealed sarcophagus, radiating power.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Tomb', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }, { type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Iron Labyrinth',
                flavor: 'An ancient dwarven labyrinth, now overrun by orcs, houses a forge crafting weapons of war. The heroes must navigate its twisting passages to destroy the forge‚Äôs heart.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Labyrinth Entrance', flavor: 'Massive iron gates mark the entrance to the dwarven maze.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Forge Outpost', flavor: 'The heat of nearby forges warms the air, mixed with orcish stench.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Smithing Hall', flavor: 'Anvils ring with the sound of orcish labor, crafting crude blades.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Ore Storage', flavor: 'Piles of raw iron gleam, ready to feed the war machine.', furniture: [{ type: 'Cupboard', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Guard Post', flavor: 'Orcish sentries watch the approach to the forge‚Äôs heart.', furniture: [], monsters: [{ type: 'Orc', count: 2 }, { type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Armory', flavor: 'Racks of weapons stand ready for the orcish horde.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'G', name: 'Forge Core', flavor: 'The massive forge roars, its heat fueled by dark magic.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'H', name: 'Warlord‚Äôs Chamber', flavor: 'The orc leader plans his conquest, surrounded by stolen loot.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }, { type: 'Orc', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'Halls of the Forgotten',
                flavor: 'An ancient elven stronghold, now a ruin haunted by the undead, holds secrets lost to time. The heroes must purge the halls of their monstrous inhabitants to uncover the truth.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Elven Gateway', flavor: 'Graceful arches crumble, etched with faded elven runes.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Moonlit Hall', flavor: 'Pale light filters through cracked skylights, illuminating dust.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ancestral Chamber', flavor: 'Ancient portraits watch silently, their eyes glowing faintly.', furniture: [{ type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Ritual Hall', flavor: 'A circle of stones pulses with forgotten elven magic.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Guard Post', flavor: 'Elven blades lie abandoned, their owners long turned to dust.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'F', name: 'Archive', flavor: 'Tomes crumble to ash, their secrets guarded by restless spirits.', furniture: [{ type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'G', name: 'Shrine', flavor: 'A defiled altar radiates sorrow, its power corrupted.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'H', name: 'Heart of the Halls', flavor: 'The source of the haunting lies here, a nexus of dark energy.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Skeleton', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Cursed Altar',
                flavor: 'A dark altar in a forsaken temple channels chaotic energies, twisting the minds of those nearby. The heroes must destroy it to restore balance to the land.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Temple Gates', flavor: 'Broken columns flank the entrance, carved with ominous runes.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Acolyte Quarters', flavor: 'Tattered robes and candles hint at recent dark rituals.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Sacrificial Hall', flavor: 'Bloodstains mark the floor, offerings to an unholy power.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Crypt', flavor: 'The dead stir in their coffins, drawn by the altar‚Äôs call.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Priest‚Äôs Chamber', flavor: 'A hidden room holds the tools of a dark priesthood.', furniture: [{ type: 'Sorcerer Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Altar Chamber', flavor: 'The cursed altar pulses, its energy warping the air.', furniture: [{ type: 'Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'G', name: 'Vault', flavor: 'Treasures of the temple lie guarded by dark forces.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'H', name: 'Inner Sanctum', flavor: 'The heart of the temple‚Äôs corruption lies here, radiating evil.', furniture: [], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Skeleton', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'Den of the Warlord',
                flavor: 'A Fimir warlord has united the swamp‚Äôs monsters under his banner, plotting to overrun the nearby villages. The heroes must infiltrate his den to end his reign.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Swamp Entrance', flavor: 'Muddy paths twist through reeds, hiding dangers in the mire.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Bog Outpost', flavor: 'Crude wooden barricades mark the Fimir‚Äôs forward camp.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Mud Hall', flavor: 'The ground squelches underfoot, the air thick with decay.', furniture: [], monsters: [{ type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Trophy Room', flavor: 'Skulls and weapons hang as grim trophies of past conquests.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Barracks', flavor: 'Crude bunks house the warlord‚Äôs monstrous troops.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'F', name: 'Strategy Room', flavor: 'Maps and crude plans litter a table, outlining the warlord‚Äôs schemes.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [] },
                    { letter: 'G', name: 'Armory', flavor: 'Weapons gleam, ready for the warlord‚Äôs growing army.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'H', name: 'Warlord‚Äôs Lair', flavor: 'The Fimir warlord broods, his power fueling the swamp‚Äôs horrors.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Fimir', count: 2 }, { type: 'Goblin', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Abyssal Shrine',
                flavor: 'A shrine to a forgotten deity lies deep underground, its power drawing cultists and monsters alike. The heroes must claim its sacred orb to prevent a catastrophe.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Cavern Entrance', flavor: 'Jagged rocks guard the descent into the shrine‚Äôs depths.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Crystal Chamber', flavor: 'Glowing crystals cast eerie light on ancient carvings.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Altar Hall', flavor: 'A massive altar looms, its surface etched with abyssal runes.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Guardian Crypt', flavor: 'Sarcophagi stand sentinel, their occupants stirring.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Sacrificial Chamber', flavor: 'The air is thick with the scent of ancient blood offerings.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Priest‚Äôs Quarters', flavor: 'Robes and dark tomes hint at the shrine‚Äôs keepers.', furniture: [{ type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'G', name: 'Shrine Vault', flavor: 'The orb rests within, its glow pulsing with otherworldly power.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }], traps: [] },
                    { letter: 'H', name: 'Abyssal Core', flavor: 'The shrine‚Äôs heart radiates darkness, guarded by fanatical devotees.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }, { type: 'Skeleton', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Wraith‚Äôs Dominion',
                flavor: 'A wraith has claimed an ancient fortress, its ghostly presence binding the dead to its will. The heroes must destroy its tomb to banish it forever.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Fortress Gate', flavor: 'The gates hang ajar, a cold wind whispering through the cracks.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Courtyard', flavor: 'Dead vines cling to crumbling walls, stirred by an unseen force.', furniture: [], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Armory', flavor: 'Rusty weapons lie scattered, animated by the wraith‚Äôs power.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Great Hall', flavor: 'A ghostly banquet table stands, its chairs filled with shadows.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Crypt Entrance', flavor: 'A sealed door pulses with the wraith‚Äôs dark energy.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'F', name: 'Wraith‚Äôs Lair', flavor: 'The air shimmers with ghostly light, the wraith‚Äôs presence palpable.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'G', name: 'Treasure Vault', flavor: 'The wraith‚Äôs hoard glimmers, guarded by its minions.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'H', name: 'Tomb Chamber', flavor: 'The wraith‚Äôs tomb radiates cold, its power binding the fortress.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Skeleton', count: 1 }], traps: [] }
                ]
            },

            // 10 Quests with 6 Rooms
            {
                name: 'Echoes of the Abyss',
                flavor: 'A rift to the abyss has opened beneath a ruined monastery, summoning a gargoyle to guard its secrets. The heroes must face the horrors within to seal the rift.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Monastery Ruins', flavor: 'Crumbled walls echo with the chants of long-dead monks.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Cloister', flavor: 'Ancient vines choke the stone, hiding dangers in the shadows.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Sacristy', flavor: 'Holy relics lie defiled, tainted by the abyss‚Äôs touch.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Crypt', flavor: 'The dead stir, drawn by the rift‚Äôs dark call.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Abyss Gate', flavor: 'A pulsing rift tears at reality, guarded by dark forces.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Gargoyle‚Äôs Sanctum', flavor: 'The gargoyle perches above the rift, its eyes glowing with malice.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }, { type: 'Skeleton', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Blighted Forge',
                flavor: 'A cursed forge churns out weapons imbued with dark magic, arming an orcish horde. The heroes must destroy its heart to halt the production.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Forge Entrance', flavor: 'The air shimmers with heat, the clang of hammers echoing.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Smelter', flavor: 'Molten metal glows, tended by orcish smiths.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Armory', flavor: 'Racks of cursed blades gleam, ready for battle.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Smith‚Äôs Quarters', flavor: 'Crude bunks hold the forge‚Äôs brutal overseers.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Forge Heart', flavor: 'The cursed forge roars, its power fueling the horde.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Treasure Vault', flavor: 'The orcs‚Äô ill-gotten gains lie piled in the shadows.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'Tunnels of Despair',
                flavor: 'A network of tunnels beneath a cursed mountain holds a crystal key, said to unlock a forgotten power. The heroes must brave its depths to claim it.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Tunnel Mouth', flavor: 'A dark passage yawns, its air heavy with dread.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Collapsed Shaft', flavor: 'Rubble blocks parts of the tunnel, hiding lurking threats.', furniture: [], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Crystal Cavern', flavor: 'Glowing crystals pulse, casting eerie light on the walls.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Guard Post', flavor: 'Monsters stand watch, protecting the tunnel‚Äôs secrets.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Key Chamber', flavor: 'The crystal key rests on a pedestal, guarded by dark forces.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Deep Vault', flavor: 'Ancient relics lie hidden, their power calling to the brave.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Necromancer‚Äôs Hold',
                flavor: 'A necromancer has fortified an ancient keep, raising the dead to serve him. The heroes must destroy his sorcerous table to end his reign of terror.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Keep Entrance', flavor: 'The gates creak, revealing a courtyard filled with bones.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Bone Hall', flavor: 'Skulls line the walls, animated by dark magic.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Guard Room', flavor: 'Undead sentries stand watch, their eyes glowing faintly.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Ritual Chamber', flavor: 'Runes pulse on the floor, fueling the necromancer‚Äôs power.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Sorcerer‚Äôs Lair', flavor: 'The necromancer‚Äôs table glows, the source of his dark magic.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Crypt Vault', flavor: 'Treasures of the dead lie guarded by restless spirits.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Bloodied Throne',
                flavor: 'A warlord‚Äôs throne, stained with the blood of countless victims, sits in a ruined fortress. The heroes must defeat its guardians to claim its power.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Fortress Gate', flavor: 'Broken siege engines litter the approach to the throne.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Barracks', flavor: 'Crude bunks hold the warlord‚Äôs brutal minions.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Armory', flavor: 'Weapons gleam, ready for the warlord‚Äôs next conquest.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Great Hall', flavor: 'Banners of fallen foes hang, stained with blood.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Throne Room', flavor: 'The bloodied throne looms, radiating dark power.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Treasure Vault', flavor: 'The warlord‚Äôs hoard glitters, guarded by his elite.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'Caverns of the Lost',
                flavor: 'A labyrinth of caverns holds an ancient amulet, its power sought by dark forces. The heroes must retrieve it before it falls into the wrong hands.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Cavern Entrance', flavor: 'Jagged rocks guard the descent into the unknown.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Flooded Chamber', flavor: 'Water drips from stalactites, pooling in the darkness.', furniture: [], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Crystal Vault', flavor: 'Crystals glow faintly, illuminating ancient relics.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Guard Post', flavor: 'Monsters lurk, protecting the cavern‚Äôs secrets.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Amulet Chamber', flavor: 'The amulet rests on a pedestal, its power pulsing.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Deep Cavern', flavor: 'The air grows heavy, the cavern hiding ancient dangers.', furniture: [], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Shadow Maze',
                flavor: 'A maze of shadows twists through an ancient ruin, its paths shifting under dark magic. The heroes must destroy a cursed table to dispel the illusion.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Maze Entrance', flavor: 'The walls shimmer, their shapes distorting in the gloom.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Twisting Path', flavor: 'The corridors bend unnaturally, disorienting all who pass.', furniture: [], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Shadow Chamber', flavor: 'Shadows dance on the walls, hiding lurking threats.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Guard Post', flavor: 'Monsters patrol the maze, guided by dark magic.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Illusion Core', flavor: 'The cursed table pulses, sustaining the maze‚Äôs deception.', furniture: [{ type: 'Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Treasure Vault', flavor: 'Hidden riches lie within, guarded by the maze‚Äôs minions.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Orcish Outpost',
                flavor: 'An orcish outpost threatens nearby villages, its warriors preparing for war. The heroes must defeat the orc leader to disrupt their plans.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Outpost Gate', flavor: 'Crude wooden stakes mark the orcish stronghold‚Äôs entrance.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Barracks', flavor: 'Orcish warriors rest, their weapons close at hand.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'War Room', flavor: 'Maps and crude plans outline the orcs‚Äô next raid.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Armory', flavor: 'Weapons pile high, ready for the orcish horde.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Chieftain‚Äôs Lair', flavor: 'The orc leader plans his conquest, surrounded by loot.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Orc', count: 2 }, { type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Treasure Hoard', flavor: 'The orcs‚Äô plunder glitters, guarded by their elite.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Ancient Sepulcher',
                flavor: 'A forgotten sepulcher houses a tomb radiating dark energy, awakening the dead. The heroes must destroy it to end the haunting.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Sepulcher Entrance', flavor: 'A heavy stone door grinds open, revealing a dark stair.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Burial Corridor', flavor: 'The walls are lined with niches, their occupants restless.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ossuary', flavor: 'Bones clatter underfoot, animated by dark forces.', furniture: [], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Ritual Chamber', flavor: 'Runes glow faintly, fueling the sepulcher‚Äôs curse.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Tomb Vault', flavor: 'The cursed tomb pulses, its energy binding the dead.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] },
                    { letter: 'F', name: 'Treasure Chamber', flavor: 'Ancient relics lie guarded by the sepulcher‚Äôs horrors.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Chaos Sanctum',
                flavor: 'A hidden sanctum channels chaotic energies, summoning monsters to wreak havoc. The heroes must defeat the chaos warrior leading the ritual to stop it.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Sanctum Entrance', flavor: 'The air hums with chaotic power, the walls pulsing faintly.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Acolyte Chamber', flavor: 'Robes and dark tomes litter the floor, signs of devotion.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ritual Hall', flavor: 'Runes glow on the floor, channeling chaotic energies.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Guard Post', flavor: 'Monsters stand watch, protecting the sanctum‚Äôs heart.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Chaos Altar', flavor: 'The chaos warrior leads a dark ritual, his power growing.', furniture: [{ type: 'Throne', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 2 }], traps: [] },
                    { letter: 'F', name: 'Treasure Vault', flavor: 'The sanctum‚Äôs riches lie hidden, guarded by its minions.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },

            // 10 Quests with 5 Rooms
            {
                name: 'The Witch‚Äôs Lair',
                flavor: 'A malevolent witch has woven a spell of despair over the land, her lair hidden in a dark forest. The heroes must destroy her sorcerous table to break her power.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Forest Path', flavor: 'Twisted branches block the sun, the air thick with magic.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Witch‚Äôs Grove', flavor: 'Strange herbs grow in unnatural patterns, glowing faintly.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ritual Circle', flavor: 'Runes pulse in the dirt, channeling the witch‚Äôs dark magic.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Guard Post', flavor: 'The witch‚Äôs minions lurk, protecting her inner sanctum.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Witch‚Äôs Sanctum', flavor: 'The sorcerous table glows, the source of her dark power.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Goblin Warrens',
                flavor: 'Goblins have overrun a network of tunnels, holding captives from nearby villages. The heroes must defeat their forces to free the prisoners.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Potion card',
                rooms: [
                    { letter: 'A', name: 'Warren Entrance', flavor: 'A jagged cave mouth reeks of goblin filth and decay.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 3 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Goblin Den', flavor: 'Crude bedding and stolen goods clutter the damp chamber.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Torture Chamber', flavor: 'Cries echo from crude cages, the prisoners‚Äô fate dire.', furniture: [{ type: 'Torture Rack', count: 1 }], monsters: [{ type: 'Orc', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Chieftain‚Äôs Lair', flavor: 'The goblin leader hoards his loot, surrounded by guards.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Goblin', count: 3 }, { type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Escape Tunnel', flavor: 'A narrow passage offers hope for the rescued captives.', furniture: [], monsters: [{ type: 'Goblin', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Forgotten Armory',
                flavor: 'An ancient armory, buried beneath a ruined keep, holds a legendary blade. The heroes must retrieve it before it falls into enemy hands.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Keep Ruins', flavor: 'Crumbling stones mark the entrance to the lost armory.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Guard Post', flavor: 'Rusty armor stands watch, animated by dark forces.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Forge Hall', flavor: 'Cold forges lie silent, their fires long extinguished.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Weapon Vault', flavor: 'Ancient blades gleam, guarded by restless spirits.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Blade Chamber', flavor: 'The legendary blade rests in a chest, radiating power.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Cursed Catacombs',
                flavor: 'A network of catacombs harbors a cursed tomb, its power awakening the dead. The heroes must destroy it to lift the curse.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Catacomb Entrance', flavor: 'A dark stair descends into the earth, cold and foreboding.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Burial Corridor', flavor: 'Niched walls hold crumbling coffins, stirring with unrest.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ossuary', flavor: 'Bones pile high, animated by the tomb‚Äôs dark magic.', furniture: [], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Cursed Tomb', flavor: 'The tomb pulses with energy, the source of the curse.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Treasure Vault', flavor: 'Ancient relics lie hidden, guarded by the catacomb‚Äôs horrors.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Fimir‚Äôs Den',
                flavor: 'A Fimir clan has claimed a swampy ruin, their presence poisoning the land. The heroes must defeat their leader to end their threat.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Potion card',
                rooms: [
                    { letter: 'A', name: 'Swamp Path', flavor: 'Muddy trails wind through reeds, hiding lurking dangers.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Bog', flavor: 'The air hums with insects, the ground soft and treacherous.', furniture: [], monsters: [{ type: 'Fimir', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Ruined Hall', flavor: 'Crumbled stone walls mark the Fimir‚Äôs crude home.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Trophy Room', flavor: 'Skulls and crude trophies adorn the Fimir‚Äôs lair.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Chieftain‚Äôs Den', flavor: 'The Fimir leader broods, his power poisoning the swamp.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Fimir', count: 2 }, { type: 'Goblin', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Dark Forge',
                flavor: 'A hidden forge produces weapons for a dark army, its fires fueled by chaos. The heroes must destroy its weapons rack to stop the production.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Forge Entrance', flavor: 'The heat of the forge sears the air, echoing with hammers.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Smelter', flavor: 'Molten metal glows, tended by orcish smiths.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Armory', flavor: 'Weapons pile high, ready for the dark army.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Forge Core', flavor: 'The forge‚Äôs heart roars, its fires fueled by chaos.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Treasure Vault', flavor: 'The forge‚Äôs riches lie hidden, guarded by its minions.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Spectral Vault',
                flavor: 'A ghostly vault holds a chalice of immense power, guarded by spirits and monsters. The heroes must retrieve it to prevent its misuse.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Vault Entrance', flavor: 'A cold wind blows through the cracked stone doors.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Ghostly Corridor', flavor: 'Shadows flicker, the air heavy with spectral presence.', furniture: [], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Spectral Chamber', flavor: 'Ghostly lights dance, guarding the vault‚Äôs secrets.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Guard Post', flavor: 'Undead sentries watch, their eyes glowing in the dark.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Chalice Vault', flavor: 'The ghostly chalice glows, its power barely contained.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Chaos Spire',
                flavor: 'A towering spire houses a chaotic ritual, its power growing with each passing moment. The heroes must defeat the chaos warrior to stop it.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Spire Base', flavor: 'The spire looms above, its stones pulsing with chaos.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Ritual Hall', flavor: 'Runes glow on the walls, fueling the chaotic ritual.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Guard Post', flavor: 'Monsters stand watch, protecting the spire‚Äôs heart.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Chaos Altar', flavor: 'The altar pulses, the ritual nearing completion.', furniture: [{ type: 'Throne', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Treasure Vault', flavor: 'The spire‚Äôs riches lie hidden, guarded by its minions.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Gargoyle', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Hidden Tomb',
                flavor: 'Beneath a ruined temple, a secret tomb harbors a rift to another realm, spewing forth horrors. The heroes must destroy the tomb to seal the rift and prevent an invasion.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Temple Ruins', flavor: 'Crumbling columns cast long shadows, hiding ancient dangers.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Sacred Corridor', flavor: 'Faded murals depict forgotten gods, their eyes glowing faintly.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Antechamber', flavor: 'The air hums with otherworldly energy, the rift‚Äôs influence growing.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Guardian Crypt', flavor: 'Ancient sentinels stir, protecting the tomb‚Äôs dark secret.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Rift Tomb', flavor: 'The tomb pulses with chaotic energy, the rift tearing at reality.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Orcish Hold',
                flavor: 'A fortified orcish hold threatens the countryside, its warriors raiding with impunity. The heroes must infiltrate the stronghold and defeat all orcs to secure it.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Hold Entrance', flavor: 'Crude wooden gates bar the way, guarded by orcish sentries.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Barracks', flavor: 'Orcish warriors rest, their weapons piled haphazardly.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'War Room', flavor: 'Crude maps outline the orcs‚Äô plans for further raids.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Chieftain‚Äôs Hall', flavor: 'The orc leader commands his horde, surrounded by loot.', furniture: [{ type: 'Throne', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 3 }, { type: 'Fimir', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'E', name: 'Treasure Vault', flavor: 'The orcs‚Äô plunder glitters, a prize for the victorious.', furniture: [{ type: 'Treasure Chest', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Ghostly Passage',
                flavor: 'A spectral passage beneath a haunted moor holds a spirit gem, its power binding restless ghosts. The heroes must retrieve it to lay the spirits to rest.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Moor Entrance', flavor: 'Mist swirls around a hidden stair, whispers echoing from below.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Spectral Corridor', flavor: 'Ghostly lights flicker, guiding or misleading the unwary.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Gem Chamber', flavor: 'The spirit gem glows within a chest, guarded by shadows.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Skeleton Keep',
                flavor: 'A crumbling keep swarms with animated skeletons, their bones clattering in endless patrol. The heroes must defeat them all to cleanse the keep.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Keep Gate', flavor: 'Rusted portcullis hangs ajar, bones crunching underfoot.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Courtyard', flavor: 'Skeletons patrol in eerie silence, their eyes glowing faintly.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Skeleton', count: 3 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Great Hall', flavor: 'A skeletal host gathers, animated by a dark curse.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Skeleton', count: 4 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] }
                ]
            },
            {
                name: 'The Sorcerer‚Äôs Cell',
                flavor: 'A mad sorcerer has barricaded himself in a dungeon cell, his enchantments wreaking havoc. The heroes must destroy his sorcerer table to end the chaos.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Dungeon Entrance', flavor: 'A heavy iron door creaks open, revealing a dark stair.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Guard Post', flavor: 'Crude weapons lie scattered, the sorcerer‚Äôs minions alert.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Sorcerer‚Äôs Cell', flavor: 'The sorcerer‚Äôs table pulses, his enchantments spiraling out of control.', furniture: [{ type: 'Sorcerer Table', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Goblin Hideout',
                flavor: 'Goblins have kidnapped a noble, hiding them in a filthy warren. The heroes must defeat the goblin leader to rescue the captive.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Potion card',
                rooms: [
                    { letter: 'A', name: 'Hideout Entrance', flavor: 'A foul stench wafts from a cave mouth, littered with bones.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Goblin Den', flavor: 'Crude bedding and stolen goods mark the goblins‚Äô lair.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Goblin', count: 3 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Prison Cell', flavor: 'The captive languishes behind crude bars, guarded by the goblin leader.', furniture: [{ type: 'Torture Rack', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }, { type: 'Orc', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Zombie Crypt',
                flavor: 'A cursed crypt spawns endless zombies, threatening nearby villages. The heroes must destroy the tomb at its heart to stop the undead.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Crypt Entrance', flavor: 'A stone slab grinds open, revealing a stair into darkness.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Burial Corridor', flavor: 'Moans echo from the shadows, the undead stirring.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 3 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Tomb Chamber', flavor: 'The cursed tomb radiates dark energy, spawning zombies.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }, { type: 'Mummy', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Chaos Vault',
                flavor: 'A hidden vault contains a chaos rune, its power sought by dark forces. The heroes must retrieve it to prevent its misuse.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Vault Entrance', flavor: 'Ancient wards glow faintly, guarding the vault‚Äôs secrets.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Trap Corridor', flavor: 'The floor clicks ominously, rigged with deadly traps.', furniture: [], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }, { type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'C', name: 'Guard Chamber', flavor: 'Monsters lurk, protecting the vault‚Äôs inner sanctum.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Rune Vault', flavor: 'The chaos rune glows within a chest, radiating power.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [] }
                ]
            },
            {
                name: 'The Fimir‚Äôs Lair',
                flavor: 'A Fimir chieftain rules a swampy lair, his minions terrorizing the region. The heroes must defeat him to end their reign of fear.',
                rewards: 'Draw 3 Treasure cards, Draw 1 Potion card',
                rooms: [
                    { letter: 'A', name: 'Swamp Path', flavor: 'Muddy trails twist through the mire, hiding Fimir scouts.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Bog', flavor: 'The ground squelches, the air thick with swamp stench.', furniture: [], monsters: [{ type: 'Fimir', count: 1 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Lair Outpost', flavor: 'Crude barricades mark the Fimir‚Äôs inner defenses.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] },
                    { letter: 'D', name: 'Chieftain‚Äôs Den', flavor: 'The Fimir chieftain lurks, his power fueling the swamp‚Äôs horrors.', furniture: [{ type: 'Throne', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Fimir', count: 2 }], traps: [] }
                ]
            },
            {
                name: 'The Cursed Armory',
                flavor: 'An armory cursed by ancient blood magic produces weapons that corrupt their wielders. The heroes must destroy the weapons rack to break the curse.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Weapon card',
                rooms: [
                    { letter: 'A', name: 'Armory Entrance', flavor: 'Rusty gates groan, the air heavy with dark magic.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Forge Hall', flavor: 'Cold forges stand silent, tainted by blood magic.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Orc', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Guard Post', flavor: 'Cursed weapons animate, attacking all who approach.', furniture: [{ type: 'Weapons Rack', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [] },
                    { letter: 'D', name: 'Cursed Vault', flavor: 'The weapons rack pulses, the source of the armory‚Äôs curse.', furniture: [{ type: 'Weapons Rack', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] }
                ]
            },
            {
                name: 'The Dark Library',
                flavor: 'A forbidden library holds a tome of shadows, its knowledge coveted by evil forces. The heroes must retrieve it to safeguard its secrets.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Artifact card',
                rooms: [
                    { letter: 'A', name: 'Library Entrance', flavor: 'Dust chokes the air, shelves groaning under ancient tomes.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Reading Room', flavor: 'Scattered scrolls hint at forbidden knowledge, guarded by shadows.', furniture: [{ type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Goblin', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Archive', flavor: 'Tomes whisper faintly, their pages alive with dark magic.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Tome Vault', flavor: 'The tome of shadows rests in a chest, radiating dark power.', furniture: [{ type: 'Treasure Chest', count: 1 }, { type: 'Bookshelf', count: 1 }], monsters: [{ type: 'Chaos Warrior', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] }
                ]
            },
            {
                name: 'The Mummy‚Äôs Tomb',
                flavor: 'An ancient mummy‚Äôs tomb radiates a curse, binding its occupant to the mortal realm. The heroes must destroy the tomb to banish the mummy.',
                rewards: 'Draw 2 Treasure cards, Draw 1 Spell card',
                rooms: [
                    { letter: 'A', name: 'Tomb Entrance', flavor: 'A sealed stone door grinds open, revealing a dark passage.', furniture: [{ type: 'Staircase', count: 1 }], monsters: [{ type: 'Skeleton', count: 2 }], traps: [{ type: 'Pit Trap', count: 1 }] },
                    { letter: 'B', name: 'Burial Corridor', flavor: 'Ancient bandages trail across the floor, the mummy‚Äôs presence near.', furniture: [{ type: 'Tomb', count: 1 }], monsters: [{ type: 'Zombie', count: 2 }], traps: [{ type: 'Spear Trap', count: 1 }] },
                    { letter: 'C', name: 'Antechamber', flavor: 'The air grows heavy, the mummy‚Äôs curse palpable.', furniture: [{ type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }], traps: [] },
                    { letter: 'D', name: 'Mummy‚Äôs Tomb', flavor: 'The tomb radiates dark energy, binding the mummy‚Äôs spirit.', furniture: [{ type: 'Tomb', count: 1 }, { type: 'Table', count: 1 }], monsters: [{ type: 'Mummy', count: 1 }, { type: 'Skeleton', count: 1 }], traps: [{ type: 'Falling Rock Trap', count: 1 }] }
                ]
            }
        ];
        // --- CORE INITIALIZATION ---

        function preloadImages() {
            const urls = [
                ...Object.values(FURNITURE_IMAGES),
                ...Object.values(WALL_IMAGES),
                ...Object.values(DOOR_IMAGES),
                ...Object.values(MONSTER_IMAGES),
                ...Object.values(TRAP_IMAGES)
            ].filter(u => u);

            return Promise.all(urls.map(url => {
                return new Promise(resolve => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = url;
                    img.onload = () => { imageCache[url] = img; resolve(); };
                    img.onerror = resolve;
                });
            }));
        }

        function numberToCoords(n) { return { x: (n - 1) % GRID_WIDTH, y: Math.floor((n - 1) / GRID_WIDTH) }; }

function initializeGrid() {
    grid = [];
    doors = [];
    placedFurniture = [];
    placedMonsters = [];
    placedTraps = [];
    manualWalls = [];
    placedWalls = []; 
    
    // FIX: Clear labels when generating a new quest
    placedTexts = [];
    // Also clear any text editor UI if open
    if(document.getElementById('textEditorToolbar')) document.getElementById('textEditorToolbar').style.display = 'none';
    editingTextItem = null;

    for (let y = 0; y < GRID_HEIGHT; y++) {
        let row = [];
        for (let x = 0; x < GRID_WIDTH; x++) {
            if (useCustomLayout) {
                const tileData = customGrid[y][x]; 
                row.push({
                    type: tileData ? tileData.type : 'empty',
                    active: !!tileData,
                    occupied: false,
                    roomInstanceId: tileData ? tileData.id : null
                });
            } else {
                const cellNum = (y * GRID_WIDTH) + x + 1;
                const mapInfo = SPACE_MAPPING.find(m => m.number === cellNum);
                row.push({
                    type: mapInfo ? (mapInfo.type === 'B' ? 'room' : 'corridor') : 'empty',
                    active: false,
                    occupied: false,
                    roomInstanceId: null 
                });
            }
        }
        grid.push(row);
    }
}

        function placeDoorsAndCorridors() {
            doors = [];
            placedWalls = [];

            // 1. Dead-End Walls Scan
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    if (grid[y][x].active && grid[y][x].type === 'corridor') {
                        const neighbors = [{ x: x, y: y - 1 }, { x: x + 1, y: y }, { x: x, y: y + 1 }, { x: x - 1, y: y }];
                        neighbors.forEach((n, index) => {
                            if (n.x < 0 || n.x >= GRID_WIDTH || n.y < 0 || n.y >= GRID_HEIGHT || !grid[n.y][n.x].active) {
                                placedWalls.push({ x: x, y: y, side: index });
                            }
                        });
                    }
                }
            }

            // 2. Place Doors and Lock Entry Tiles
            activeRooms.forEach(room => {
                const potentialDoors = [];
                for (let x = room.x; x < room.x + room.width; x++) {
                    potentialDoors.push({ x: x, y: room.y - 0.5, facing: 0, rx: x, ry: room.y, ox: x, oy: room.y - 1 });
                    potentialDoors.push({ x: x, y: room.y + room.height - 0.5, facing: 2, rx: x, ry: room.y + room.height - 1, ox: x, oy: room.y + room.height });
                }
                for (let y = room.y; y < room.y + room.height; y++) {
                    potentialDoors.push({ x: room.x - 0.5, y: y, facing: 3, rx: room.x, ry: y, ox: room.x - 1, oy: y });
                    potentialDoors.push({ x: room.x + room.width - 0.5, y: y, facing: 1, rx: room.x + room.width - 1, ry: y, ox: room.x + room.width, oy: y });
                }

                const validDoors = potentialDoors.filter(p =>
                    p.ox >= 0 && p.ox < GRID_WIDTH && p.oy >= 0 && p.oy < GRID_HEIGHT && grid[p.oy][p.ox].active
                );

                const count = Math.floor(Math.random() * 2) + 1;
                for (let i = 0; i < count && validDoors.length > 0; i++) {
                    const d = validDoors.splice(Math.floor(Math.random() * validDoors.length), 1)[0];
                    const isSecret = Math.random() < 0.15;
                    doors.push({ x: d.x, y: d.y, facing: d.facing, room, secret: isSecret, revealed: true });

                    // Mark entry and exit tiles as occupied
                    if (grid[d.ry] && grid[d.ry][d.rx]) grid[d.ry][d.rx].occupied = true;
                    if (grid[d.oy] && grid[d.oy][d.ox]) grid[d.oy][d.ox].occupied = true;
                }
            });
        }



        // --- MAP MAKER LOGIC ---
// 1. New Helper Function: Contains the actual logic to wipe the board
function performMapClear() {
    console.log("1. Starting Map Clear..."); // Debug Log for F12 Console

    try {
        // 1. Force Canvas Wipe
        if(ctx) ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // 2. Clear Custom Grid
        if (typeof customGrid !== 'undefined') {
            customGrid = Array(GRID_HEIGHT).fill().map(() => Array(GRID_WIDTH).fill(null));
        }

        // 3. Clear Live Game Grid
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (grid[y] && grid[y][x]) {
                    grid[y][x].active = false;
                    grid[y][x].type = 'empty';
                    grid[y][x].roomInstanceId = null;
                    grid[y][x].occupied = false;
                }
            }
        }

        // 4. Wipe Arrays (Check existence first to prevent crashes)
        if (typeof placedFurniture !== 'undefined') placedFurniture.length = 0;
        if (typeof placedMonsters !== 'undefined') placedMonsters.length = 0;
        if (typeof placedTraps !== 'undefined') placedTraps.length = 0;
        if (typeof doors !== 'undefined') doors.length = 0;
        if (typeof manualWalls !== 'undefined') manualWalls.length = 0;
        if (typeof activeRooms !== 'undefined') activeRooms.length = 0;
        if (typeof players !== 'undefined') players.length = 0;
        if (typeof placedTexts !== 'undefined') placedTexts.length = 0;

        // 5. Clear State
        draggedItem = null;
        if (typeof selectedBrush !== 'undefined') selectedBrush.type = null;
        if (typeof currentQuest !== 'undefined' && currentQuest) currentQuest.wanderingMonster = null;
        
        // Hide Text Toolbar
        const tb = document.getElementById('textEditorToolbar');
        if (tb) tb.style.display = 'none';
        if (typeof editingTextItem !== 'undefined') editingTextItem = null;

        // 6. Visual Reset
        try { rebuildOccupancy(); } catch (e) { console.warn("rebuildOccupancy error", e); }
        try { drawEditor(); } catch (e) { console.warn("drawEditor error", e); }
        try { drawBoard(); } catch (e) { console.warn("drawBoard error", e); }
        try { updateQuestUI(); } catch (e) { console.warn("updateQuestUI error", e); }
        
        // Reset Side Panel Selection
        const options = document.querySelectorAll('#tileSidePanel .tile-option');
        if (options) options.forEach(el => el.classList.remove('selected'));

        console.log("2. Map Clear Successful");

    } catch (err) {
        console.error("Critical Clear Error:", err);
        // Fallback: If code crashes, force a reload alert so user knows
        alert("An error occurred while clearing. The map might be partially cleared.");
    }
}
// 2. Updated clearMap Function: Triggers the internal modal
function clearMap() {
    console.log("Clear Map Button Pressed"); // Debug Log
    showConfirmModal(
        "Clear Map?", 
        "Are you sure you want to clear everything? This cannot be undone.", 
        performMapClear
    );
}

        function toggleMapMakerMode() {
            isEditMode = !isEditMode;

            const tileBtn = document.getElementById('tilePanelBtn');
            const tilePanel = document.getElementById('tileSidePanel');
            const toolbar = document.getElementById('mapMakerToolbar');
            const modeBtn = document.getElementById('mapModeBtn');

            if (isEditMode) {
                if (isQuestEditMode) toggleQuestEditMode();

                // --- NEW: IMPORT CURRENT MAP INTO EDITOR ---
                // This copies the currently generated/active map into the Map Maker's memory
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const cell = grid[y][x];
                        if (cell.active) {
                            customGrid[y][x] = {
                                type: cell.type,
                                id: cell.roomInstanceId,
                                isPaintedRoom: cell.type === 'room'
                            };
                        } else {
                            customGrid[y][x] = null;
                        }
                    }
                }

                if (tileBtn) tileBtn.style.display = 'inline-block';
                if (tilePanel) tilePanel.style.display = 'block';
                if (toolbar) toolbar.style.display = 'flex';
                if (modeBtn) {
                    modeBtn.innerText = "Exit Maker";
                    modeBtn.style.background = "#f44336";
                }
                drawEditor();
            } else {
                // --- NEW: SAVE EDITOR CHANGES BACK TO ACTIVE MAP ---
                useCustomLayout = true;

                // Sync customGrid back to the live grid
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const source = customGrid[y][x];
                        grid[y][x].active = !!source;
                        grid[y][x].type = source ? source.type : 'empty';
                        grid[y][x].roomInstanceId = source ? source.id : null;
                    }
                }

                if (tileBtn) tileBtn.style.display = 'none';
                if (tilePanel) tilePanel.style.display = 'none';
                if (toolbar) toolbar.style.display = 'none';
                if (modeBtn) {
                    modeBtn.innerText = "Enter Map Maker";
                    modeBtn.style.background = "#b22222";
                }

                // We do NOT call generateQuest() here. 
                // We just redraw the board with the updated tiles.
                rebuildOccupancy();
                drawBoard();
            }
        }
		
		function handleOverlayClick() {
    // 1. Check Confirm Modal (Clear Map)
    if (document.getElementById('confirmModal').style.display === 'block') {
        closeConfirmModal();
        return;
    }
    // 2. Check Vault
    const vault = document.getElementById('vaultModal');
    if (vault.style.display === 'flex' || vault.style.display === 'block') {
        toggleVault();
        return;
    }
    // 3. Check Community
    const comm = document.getElementById('communityModal');
    if (comm.style.display === 'flex' || comm.style.display === 'block') {
        toggleCommunity();
        return;
    }
    // 4. Check Share
    if (document.getElementById('shareModal').style.display === 'block') {
        // Manually close share to avoid login check loops
        document.getElementById('shareModal').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
        return;
    }
    // 5. Check Auth/Login
    if (document.getElementById('authModal').style.display === 'block') {
        toggleAuthModal();
        return;
    }
    // 6. Check Alerts
    if (document.getElementById('alertModal').style.display === 'block') {
        closeCustomAlert();
        return;
    }
    // 7. Check Wandering Monster Picker
    if (document.getElementById('wmModal').style.display === 'block') {
        document.getElementById('wmModal').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
        return;
    }
    // 8. Check Profile
    if (document.getElementById('profileModal').style.display === 'block') {
        toggleProfileModal();
        return;
    }
    // 9. Check Room Notes
    if (document.getElementById('roomNotesModal').style.display === 'block') {
        toggleRoomNotes();
        return;
    }

    // Fallback: Just hide the overlay if nothing else matched
    document.getElementById('overlay').style.display = 'none';
}

        function toggleEditorBoard() {
            const bgImg = document.getElementById('backgroundImage');
            if (bgImg.style.visibility === 'hidden') {
                bgImg.style.visibility = 'visible';
                bgImg.style.opacity = '0.7'; // Matches the new CSS brightness
            } else {
                bgImg.style.visibility = 'hidden';
            }
        }

        canvas.addEventListener('wheel', (e) => {
            if (!isEditMode) return;
            e.preventDefault();
            selectedBrush.rot = (selectedBrush.rot + 90) % 360;
            document.getElementById('rotVal').innerText = selectedBrush.rot;
            drawEditor();
        });

canvas.addEventListener('mousemove', (e) => {
    // 1. Calculate precise grid coordinates based on canvas scale
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    // mx and my are the exact floating point grid units (e.g. 5.42)
    const mx = (e.clientX - rect.left) * scaleX / SPACE_WIDTH;
    const my = (e.clientY - rect.top) * scaleY / SPACE_HEIGHT;

    // Update global mousePos for logic that requires whole tile integers
    mousePos.x = Math.floor(mx);
    mousePos.y = Math.floor(my);

    // 2. Scenario: Dragging items in Editor Mode
    if (isQuestEditMode && draggedItem) {
        if (draggedItem.type_id === 'door') {
            // DOORS: Snap to the lines between tiles (0.5 offsets)
            if (draggedItem.facing % 2 === 0) {
                // Top (0) or Bottom (2) walls: Snap X to tile center, Y to horizontal line
                draggedItem.x = Math.floor(mx);
                draggedItem.y = Math.floor(my + 0.5) - 0.5;
            } else {
                // Right (1) or Left (3) walls: Snap X to vertical line, Y to tile center
                draggedItem.x = Math.floor(mx + 0.5) - 0.5;
                draggedItem.y = Math.floor(my);
            }
        } 
        else if (draggedItem.type_id === 'furniture' || draggedItem.type_id === 'wall') {
            // MULTI-TILE ASSETS: Use dragOffset so the item doesn't "jump" to the top-left corner
            draggedItem.x = Math.floor(mx) - dragOffset.x;
            draggedItem.y = Math.floor(my) - dragOffset.y;
        } 
        else if (draggedItem.type_id === 'label') {
            // LABELS: Snap to whole tile
            draggedItem.x = Math.floor(mx);
            draggedItem.y = Math.floor(my);
        } 
        else {
            // MONSTERS & TRAPS: Standard 1x1 grid snapping
            draggedItem.x = Math.floor(mx);
            draggedItem.y = Math.floor(my);
        }

        // Refresh the canvas to show movement in real-time
        drawBoard();
    }

    // 3. Scenario: Hovering a Ghost Brush in "Map Maker" Mode
    // (Note: With Unified Editor, isEditMode is usually true whenever panels are open)
    else if (isEditMode) {
        // If we are painting tiles, use drawEditor
        if (selectedBrush && selectedBrush.type) {
            drawEditor();
        } else {
            // If just hovering (Move Tool), use drawBoard to show cursor
            drawBoard();
        }
    }
});

        // Disable the standard browser right-click menu on the canvas
        canvas.addEventListener('contextmenu', (e) => {
            // We only prevent the menu if the user is in one of the edit modes
            if (isEditMode || isQuestEditMode) {
                e.preventDefault();
            }
        }, false);

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    // Pixel coordinates (for Text Box Handle checks)
    const clickX = (e.clientX - rect.left) * scaleX;
    const clickY = (e.clientY - rect.top) * scaleY;
    
    // Grid coordinates (for Tile/Asset logic)
    const mx = clickX / SPACE_WIDTH;
    const my = clickY / SPACE_HEIGHT;
    const gx = Math.floor(mx);
    const gy = Math.floor(my);

    // --- MIDDLE MOUSE CLICK: CANCEL ---
    if (e.button === 1) {
        e.preventDefault();
        if (isEditMode) selectedBrush.type = null;
        if (draggedItem) draggedItem = null;
        if (editingTextItem) closeTextEditor();
        drawEditor();
        drawBoard();
        return;
    }

    // --- EDITOR INTERACTIONS ---
    if (isQuestEditMode) {
        
        // 1. Text Box Handles (Resize/Rotate)
        if (editingTextItem) {
            const t = editingTextItem;
            // Simple hit tests assuming unrotated handles for simplicity
            // (If rotated, handles visually rotate, logic here uses bounding box approx)
            
            const px = t.x * SPACE_WIDTH;
            const py = t.y * SPACE_HEIGHT;
            const pw = t.width * SPACE_WIDTH;
            const ph = t.height * SPACE_HEIGHT;
            
            // Check Rotation Handle (Top Center)
            if (Math.abs(clickX - (px + pw/2)) < 20 && Math.abs(clickY - (py - 20)) < 20) {
                resizeHandle = 'rot';
                return;
            }
            // Check Resize Handle (Bottom Right)
            if (Math.abs(clickX - (px + pw)) < 20 && Math.abs(clickY - (py + ph)) < 20) {
                resizeHandle = 'br';
                return;
            }
        }

        // 2. Click on Existing Text Box (Select / Move)
        for (let i = placedTexts.length - 1; i >= 0; i--) {
            const t = placedTexts[i];
            const px = t.x * SPACE_WIDTH;
            const py = t.y * SPACE_HEIGHT;
            const pw = t.width * SPACE_WIDTH;
            const ph = t.height * SPACE_HEIGHT;

            // Simple hit detection
            if (clickX >= px && clickX <= px + pw && clickY >= py && clickY <= py + ph) {
                if (e.button === 2) { // Right Click Delete
                    placedTexts.splice(i, 1);
                    closeTextEditor();
                    drawBoard();
                    return;
                }
                
                // Select
                editingTextItem = t;
                showTextEditor(t);
                
                // Drag
                draggedItem = t;
                draggedItem.type_id = 'text';
                dragOffset = { x: mx - t.x, y: my - t.y };
                return;
            }
        }

        // 3. Click on Standard Assets (Move / Delete)
        const monsterIdx = placedMonsters.findIndex(m => m.x === gx && m.y === gy);
        const furnitureIdx = placedFurniture.findIndex(f => {
            const fp = getItemFootprint(f);
            return gx >= f.x && gx < f.x + fp.w && gy >= f.y && gy < f.y + fp.h;
        });
        const wallIdx = manualWalls.findIndex(w => {
            const fp = getItemFootprint(w);
            return gx >= w.x && gx < w.x + fp.w && gy >= w.y && gy < w.y + fp.h;
        });
        const trapIdx = placedTraps.findIndex(t => t.x === gx && t.y === gy);
        const doorIdx = doors.findIndex(d => {
            const thresholdX = d.secret ? 0.8 : 0.6;
            const thresholdY = d.secret ? 1.2 : 0.6;
            return Math.abs(d.x - (mx - 0.5)) < thresholdX && Math.abs(d.y - (my - 0.5)) < thresholdY;
        });

        // Delete (Right Click)
        if (e.button === 2) { 
            e.preventDefault();
            if (monsterIdx !== -1) placedMonsters.splice(monsterIdx, 1);
            else if (furnitureIdx !== -1) placedFurniture.splice(furnitureIdx, 1);
            else if (wallIdx !== -1) manualWalls.splice(wallIdx, 1);
            else if (trapIdx !== -1) placedTraps.splice(trapIdx, 1);
            else if (doorIdx !== -1) doors.splice(doorIdx, 1);
            rebuildOccupancy();
            drawBoard();
            return;
        }

        // Drag (Left Click)
        if (e.button === 0) { 
            if (monsterIdx !== -1) { draggedItem = placedMonsters[monsterIdx]; draggedItem.type_id = 'monster'; }
            else if (furnitureIdx !== -1) {
                draggedItem = placedFurniture[furnitureIdx]; draggedItem.type_id = 'furniture';
                dragOffset = { x: gx - draggedItem.x, y: gy - draggedItem.y };
            }
            else if (wallIdx !== -1) {
                draggedItem = manualWalls[wallIdx]; draggedItem.type_id = 'wall';
                dragOffset = { x: gx - draggedItem.x, y: gy - draggedItem.y };
            }
            else if (doorIdx !== -1) { draggedItem = doors[doorIdx]; draggedItem.type_id = 'door'; }
            else if (trapIdx !== -1) { draggedItem = placedTraps[trapIdx]; draggedItem.type_id = 'trap'; }
        }
    }

    // --- MAP PAINTING (If no item selected and in Edit Mode) ---
    if (isEditMode && selectedBrush.type && e.button === 0 && !draggedItem && !resizeHandle) {
        const { w, h, rot, type } = selectedBrush;
        const actualW = (rot === 90 || rot === 270) ? h : w;
        const actualH = (rot === 90 || rot === 270) ? w : h;
        
        let currentID = (type === 'room' && w === 1 && h === 1) ? `painted_${Date.now()}` : `room_${roomInstanceCounter++}`;
        if(type !== 'room') currentID = 'corridor_global';

        for (let dy = 0; dy < actualH; dy++) {
            for (let dx = 0; dx < actualW; dx++) {
                let tx = gx + dx, ty = gy + dy;
                if (tx >= 0 && tx < GRID_WIDTH && ty >= 0 && ty < GRID_HEIGHT) {
                    customGrid[ty][tx] = {
                        type: type,
                        id: currentID,
                        isPaintedRoom: (type === 'room' && w === 1 && h === 1)
                    };
                }
            }
        }
        drawEditor();
    }
    // Eraser
    else if (isEditMode && e.button === 2 && !draggedItem) {
        if (gx >= 0 && gx < GRID_WIDTH && gy >= 0 && gy < GRID_HEIGHT) {
            customGrid[gy][gx] = null;
        }
        drawEditor();
    }
});


        // --- NEW FUNCTION: TOGGLE SOURCE ---
        function toggleLayoutSource() {
            useCustomLayout = !useCustomLayout;
            const btn = document.getElementById('layoutToggleBtn');
            const bgImg = document.getElementById('backgroundImage');

            if (useCustomLayout) {
                btn.innerText = "Switch to Classic Board";
                bgImg.style.visibility = 'hidden';
            } else {
                btn.innerText = "Switch to Custom Layout";
                bgImg.style.visibility = 'visible';
            }
            generateQuest();
        }

        // Toggle side panels
        function togglePanel(id) {
            const panel = document.getElementById(id);
            panel.classList.toggle('open');
        }

        // Touch Event Logic
        function getTouchPos(touchEvent) {
            const rect = canvas.getBoundingClientRect();
            const touch = touchEvent.touches[0];
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // Map Touch to Mouse Logic
        canvas.addEventListener('touchstart', function (e) {
            const pos = getTouchPos(e);
            const mouseEvent = new MouseEvent("mousedown", {
                clientX: pos.x / (canvas.width / canvas.getBoundingClientRect().width) + canvas.getBoundingClientRect().left,
                clientY: pos.y / (canvas.height / canvas.getBoundingClientRect().height) + canvas.getBoundingClientRect().top,
                button: 0 // Simulate left click
            });
            canvas.dispatchEvent(mouseEvent);
            if (isEditMode || isQuestEditMode) e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchmove', function (e) {
            const pos = getTouchPos(e);
            const mouseEvent = new MouseEvent("mousemove", {
                clientX: pos.x / (canvas.width / canvas.getBoundingClientRect().width) + canvas.getBoundingClientRect().left,
                clientY: pos.y / (canvas.height / canvas.getBoundingClientRect().height) + canvas.getBoundingClientRect().top
            });
            canvas.dispatchEvent(mouseEvent);
            if (isEditMode || isQuestEditMode) e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', function (e) {
            const mouseEvent = new MouseEvent("mouseup", {});
            canvas.dispatchEvent(mouseEvent);
        }, { passive: false });


        function toggleQuestEditMode() {
            isQuestEditMode = !isQuestEditMode;

            const assetBtn = document.getElementById('assetPanelBtn');
            const assetPanel = document.getElementById('assetLibrary');
            const editBtn = document.getElementById('questEditBtn');

            if (isQuestEditMode) {
                // Close Map Maker if it was open to avoid overlapping
                if (isEditMode) toggleMapMakerMode();

                if (assetBtn) assetBtn.style.display = 'inline-block';
                if (assetPanel) assetPanel.style.display = 'block';
                if (editBtn) {
                    editBtn.innerText = "Save Items";
                    editBtn.style.background = "#ff9800";
                }
                populateAssetLibrary();
            } else {
                if (assetBtn) assetBtn.style.display = 'none';
                if (assetPanel) assetPanel.style.display = 'none';
                if (editBtn) {
                    editBtn.innerText = "Edit Placed Items";
                    editBtn.style.background = "#ff9800";
                }
                rebuildOccupancy();
                updateQuestUI();
            }
            drawBoard();
        }

        function toggleHelp() {
            const modal = document.getElementById('helpModal');
            const overlay = document.getElementById('overlay');
            const isVisible = modal.style.display === 'block';
            modal.style.display = isVisible ? 'none' : 'block';
            overlay.style.display = isVisible ? 'none' : 'block';
        }

function drawEditor() {
    if (!ctx) return;

    // 1. Clear the canvas
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // 2. Draw Background (Dark or Tracing Mode)
    const bgImg = document.getElementById('backgroundImage');
    const isTracing = bgImg && bgImg.style.visibility === 'visible';

    if (!isTracing) {
        ctx.fillStyle = "#111"; // Dark background for Editor
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    } else {
        ctx.fillStyle = "rgba(0, 0, 0, 0.2)"; // Semi-transparent for tracing
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    // 3. Draw Placed Tiles (From Custom Grid)
    for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
            const px = x * SPACE_WIDTH;
            const py = y * SPACE_HEIGHT;

            // Draw painted tiles from the customGrid
            if (customGrid[y][x]) {
                if (customGrid[y][x].type === 'room') {
                    ctx.fillStyle = "rgba(178, 34, 34, 0.7)"; // Crimson Red
                } else {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.7)"; // White
                }
                ctx.fillRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);

                // Draw subtle border
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                ctx.lineWidth = 1;
                ctx.strokeRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
            } else {
                // Draw empty grid lines
                ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
                ctx.lineWidth = 0.5;
                ctx.strokeRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
            }
        }
    }

    // 4. DRAW ASSETS (Layered on top of tiles)
    // We reuse the drawing logic from drawBoard here to ensure visibility during editing

    // Manual Walls
    manualWalls.forEach(w => {
        if (!w.wallData) return;
        const img = imageCache[w.wallData.imageUrl];
        if (img) {
            ctx.save();
            const fp = getItemFootprint(w);
            ctx.translate((w.x + fp.w / 2) * SPACE_WIDTH, (w.y + fp.h / 2) * SPACE_HEIGHT);
            ctx.rotate((w.facing * 90) * Math.PI / 180);
            if (draggedItem === w) { ctx.shadowBlur = 20; ctx.shadowColor = "cyan"; }
            ctx.drawImage(img, -(w.wallData.size.width * SPACE_WIDTH) / 2, -(w.wallData.size.height * SPACE_HEIGHT) / 2, SPACE_WIDTH * w.wallData.size.width, SPACE_HEIGHT * w.wallData.size.height);
            ctx.restore();
        }
    });

    // Doors
    doors.forEach(d => {
        const isSecret = d.secret;
        const doorImg = isSecret ? imageCache[DOOR_IMAGES['SecretDoor']] : imageCache[DOOR_IMAGES['Door1x1']];
        if (doorImg) {
            const dw = isSecret ? SPACE_WIDTH : DOOR_IMAGE_WIDTH;
            const dh = isSecret ? SPACE_HEIGHT * 2 : DOOR_IMAGE_HEIGHT;
            ctx.save();
            ctx.translate((d.x + 0.5) * SPACE_WIDTH, (d.y + 0.5) * SPACE_HEIGHT);
            ctx.rotate((d.facing * 90) * Math.PI / 180);
            if (draggedItem === d) { ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; }
            ctx.drawImage(doorImg, -dw / 2, -dh / 2, dw, dh);
            ctx.restore();
        }
    });

    // Furniture
    placedFurniture.forEach(f => {
        if (!f.furniture) return;
        const img = imageCache[f.furniture.imageUrl];
        if (img) {
            ctx.save();
            const fp = getItemFootprint(f);
            ctx.translate((f.x + fp.w / 2) * SPACE_WIDTH, (f.y + fp.h / 2) * SPACE_HEIGHT);
            ctx.rotate((f.facing * 90) * Math.PI / 180);
            if (draggedItem === f) { ctx.shadowBlur = 20; ctx.shadowColor = "cyan"; }
            ctx.drawImage(img, -(f.furniture.size.width * SPACE_WIDTH) / 2, -(f.furniture.size.height * SPACE_HEIGHT) / 2, SPACE_WIDTH * f.furniture.size.width, SPACE_HEIGHT * f.furniture.size.height);
            ctx.restore();
        }
    });

    // Traps
    placedTraps.forEach(t => {
        const trapData = trapTypes.find(tt => tt.name === t.type);
        if (trapData && imageCache[trapData.imageUrl]) {
            ctx.save();
            if (draggedItem === t) { ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; }
            ctx.drawImage(imageCache[trapData.imageUrl], t.x * SPACE_WIDTH, t.y * SPACE_HEIGHT, SPACE_WIDTH, SPACE_HEIGHT);
            ctx.restore();
        }
    });

    // Monsters
    placedMonsters.forEach(m => {
        if (!m.type) return;
        const img = imageCache[m.type.imageUrl];
        if (img) {
            ctx.save();
            const fp = getItemFootprint(m);
            ctx.translate((m.x + fp.w / 2) * SPACE_WIDTH, (m.y + fp.h / 2) * SPACE_HEIGHT);
            ctx.rotate((m.facing * 90) * Math.PI / 180);
            if (draggedItem === m) { ctx.shadowBlur = 15; ctx.shadowColor = "cyan"; }

            const displayWidth = (m.type.size.width === 1 && m.type.size.height === 1) ? 1 : m.type.size.width;
            const displayHeight = (m.type.size.width === 1 && m.type.size.height === 1) ? 1 : m.type.size.height;

            ctx.drawImage(img,
                -(displayWidth * SPACE_WIDTH) / 2,
                -(displayHeight * SPACE_HEIGHT) / 2,
                SPACE_WIDTH * displayWidth,
                SPACE_HEIGHT * displayHeight);
            ctx.restore();
        }
    });

    // 5. DRAW THE GHOST BRUSH (Cursor)
    if (selectedBrush && selectedBrush.type) {
        const { w, h, rot, type } = selectedBrush;

        const actualW = (rot === 90 || rot === 270) ? h : w;
        const actualH = (rot === 90 || rot === 270) ? w : h;

        ctx.fillStyle = type === 'room' ? 'rgba(178, 34, 34, 0.5)' : 'rgba(255, 255, 255, 0.5)';
        ctx.strokeStyle = "#00ffff"; // Bright cyan border
        ctx.lineWidth = 2;

        const gx = mousePos.x * SPACE_WIDTH;
        const gy = mousePos.y * SPACE_HEIGHT;
        const gw = actualW * SPACE_WIDTH;
        const gh = actualH * SPACE_HEIGHT;

        ctx.fillRect(gx, gy, gw, gh);
        ctx.strokeRect(gx, gy, gw, gh);

        // Draw rotation text
        ctx.fillStyle = "white";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "left";
        ctx.fillText(`${rot}¬∞`, gx + 5, gy + 15);
    }
}

function expandCorridors() {
    // Run this pass a few times to ensure 2-wide and 3-wide corridors fill completely
    for (let pass = 0; pass < 3; pass++) {
        // Create a temporary toggle list so we don't affect the grid while iterating
        let toActivate = [];

        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                // If this tile is an INACTIVE corridor (based on the map layout)
                if (grid[y][x].type === 'corridor' && !grid[y][x].active) {
                    
                    // Check neighbors (Up, Down, Left, Right)
                    const neighbors = [
                        {x: x+1, y: y}, {x: x-1, y: y},
                        {x: x, y: y+1}, {x: x, y: y-1}
                    ];

                    // If ANY neighbor is an ACTIVE corridor, activate this one too
                    // This "pulls" the hallway open
                    const hasActiveNeighbor = neighbors.some(n => 
                        n.x >= 0 && n.x < GRID_WIDTH && 
                        n.y >= 0 && n.y < GRID_HEIGHT &&
                        grid[n.y][n.x].active && 
                        grid[n.y][n.x].type === 'corridor'
                    );

                    if (hasActiveNeighbor) {
                        toActivate.push({x, y});
                    }
                }
            }
        }

        // Apply changes
        toActivate.forEach(t => {
            grid[t.y][t.x].active = true;
            grid[t.y][t.x].roomInstanceId = 'corridor_global';
        });
    }
}

        // --- CUSTOM ALERTS & MODALS ---
        function showCustomAlert(msg, title = "Alert") {
            document.getElementById('alertTitle').innerText = title;
            document.getElementById('alertMessage').innerText = msg;

            const m = document.getElementById('alertModal');
            const o = document.getElementById('overlay');
            m.style.display = 'block';
            o.style.display = 'block';
        }

        function closeCustomAlert() {
            document.getElementById('alertModal').style.display = 'none';
            // Only hide overlay if no other modal is open? 
            // Ideally we check others, but for now let's just Close All overlays to be safe, unless we are stacking
            // Simplification: Just hide overlay. If user was in another modal, they might need to reopen.
            // Better: Check if any other .vault-modal is block
            const modals = document.querySelectorAll('.vault-modal');
            let anyOpen = false;
            modals.forEach(m => {
                if (m.id !== 'alertModal' && m.style.display === 'block') anyOpen = true;
            });
            if (!anyOpen) document.getElementById('overlay').style.display = 'none';
        }

        // Confirm Modal Functions
        let confirmCallback = null;

function showConfirmModal(title, message, onConfirm) {
    console.log("Modal Requested:", title); // Debug Log

    const modal = document.getElementById('confirmModal');
    const overlay = document.getElementById('overlay');
    
    // FALLBACK: If HTML is missing/hidden by Wix, use native browser popup
    if (!modal || !overlay) {
        if(confirm(title + "\n" + message)) onConfirm();
        return;
    }

    // Update Text
    const titleEl = document.getElementById('confirmTitle');
    const msgEl = document.getElementById('confirmMessage');
    if(titleEl) titleEl.textContent = title;
    if(msgEl) msgEl.innerHTML = message;
    
    // Show Window
    modal.style.display = 'block';
    overlay.style.display = 'block';

    // Store the function we want to run (performMapClear)
    confirmCallback = onConfirm;

    // --- SIMPLE BINDING (No Cloning) ---
    const okBtn = document.getElementById('confirmOkBtn');
    
    // Remove existing listener by overwriting it
    okBtn.onclick = function () {
        console.log("Modal OK Clicked");
        if (typeof confirmCallback === 'function') {
            confirmCallback(); // Run the clear function
        }
        closeConfirmModal();
    };
    
    // Bind Cancel
    const cancelBtn = document.getElementById('confirmCancelBtn');
    cancelBtn.onclick = closeConfirmModal;
}

function closeConfirmModal() {
    const modal = document.getElementById('confirmModal');
    if (modal) modal.style.display = 'none';
    
    // Logic to keep overlay if other windows are open
    const openModals = document.querySelectorAll('.vault-modal, .auth-modal');
    let anyVisible = false;
    openModals.forEach(m => {
        // If any modal OTHER than confirmModal is visible, keep overlay
        if(m.id !== 'confirmModal' && m.style.display === 'block') anyVisible = true;
    });
    
    // If no other modals are open, hide overlay
    const overlay = document.getElementById('overlay');
    if(!anyVisible && overlay) overlay.style.display = 'none';
    
    confirmCallback = null;
}

        // --- VAULT STORAGE ---

        function toggleSaveModal() {
            const m = document.getElementById('saveLayoutModal');
            const o = document.getElementById('overlay');
            const isVisible = m.style.display === 'block';
            m.style.display = isVisible ? 'none' : 'block';
            o.style.display = isVisible ? 'none' : 'block';

            if (!isVisible && currentQuest) {
                document.getElementById('saveLayoutName').value = currentQuest.name || currentQuest.title || "My Quest";
            }
        }

        function saveCurrentLayout() {
            toggleSaveModal();
        }

        function confirmSaveLayout() {
            const name = document.getElementById('saveLayoutName').value;
            if (!name) return showCustomAlert("Please enter a name.");

            const layouts = JSON.parse(localStorage.getItem('hq_vault') || '[]');

            // Use getQuestData to grab EVERYTHING (Tiles, Monsters, Furniture, etc.)
            const fullData = getQuestData();

            // Add metadata like notes/tags if we have them
            // Override the name with the user input
            fullData.questName = name;
            fullData.name = name;
            fullData.timestamp = Date.now();

            layouts.push(fullData);
            localStorage.setItem('hq_vault', JSON.stringify(layouts));

            toggleSaveModal();
            showCustomAlert("Saved to Local Vault!", "Success");
        }

        let selectedLocalQuestIdx = -1;

        function toggleVault() {
            const modal = document.getElementById('vaultModal');
            const overlay = document.getElementById('overlay');
            const list = document.getElementById('vaultList');
            const isVisible = modal.style.display !== 'none';

            if (isVisible) {
                modal.style.display = 'none';
                overlay.style.display = 'none';
            } else {
                modal.style.display = 'flex'; // Use Flex for layout
                overlay.style.display = 'block';

                const layouts = JSON.parse(localStorage.getItem('hq_vault') || '[]');
                list.innerHTML = layouts.length ? '' : '<div style="padding:20px; color:#999; text-align:center;">No saved quests found.</div>';

                layouts.forEach((l, i) => {
                    const item = document.createElement('div');
                    item.style.cssText = "padding:12px; border-bottom:1px solid #eee; cursor:pointer; position:relative; transition:background 0.2s;";
                    item.onmouseover = () => item.style.background = "#f5f5f5";
                    item.onmouseout = () => item.style.background = "white";
                    item.onclick = () => selectLocalQuest(i);

                    item.innerHTML = `
                        <div style="font-weight:bold; color:#333; margin-bottom:4px;">${l.name || "Untitled Quest"}</div>
                        <div style="font-size:11px; color:#888;">${new Date(l.timestamp || Date.now()).toLocaleDateString()}</div>
                        <button onclick="event.stopPropagation(); deleteLayout(${i})" 
                            style="position:absolute; top:12px; right:10px; background:none; border:none; color:#ff5252; font-weight:bold; cursor:pointer; font-size:18px;" title="Delete">&times;</button>
                    `;
                    list.appendChild(item);
                });

                // Reset Preview
                const pContainer = document.getElementById('vaultPreviewContainer');
                if (pContainer) pContainer.innerHTML = '<div style="padding:40px; text-align:center; color:#666;">Select a quest to preview</div>';
                selectedLocalQuestIdx = -1;
            }
        }

        function selectLocalQuest(idx) {
            selectedLocalQuestIdx = idx;
            const layouts = JSON.parse(localStorage.getItem('hq_vault') || '[]');
            const data = layouts[idx];
            if (!data) return;

            // Render Preview with generic metadata
            renderFullPreview(data, 'vaultPreviewContainer', {
                author: "Me",
                rating: 0,
                date: new Date(data.timestamp || Date.now()).toLocaleDateString()
            });

            // Inject "Load" button into header
            const container = document.getElementById('vaultPreviewContainer');
            const headerFlex = container.querySelector('div > div[style*="justify-content:space-between"]');
            if (headerFlex) {
                const btn = document.createElement('button');
                btn.innerText = "Load Quest";
                btn.onclick = () => loadLayout(idx);
                btn.style.cssText = "background:#2196F3; color:white; border:none; padding:10px 20px; cursor:pointer; font-size:14px; border-radius:4px; font-weight:bold; white-space:nowrap; margin-left:15px;";
                headerFlex.appendChild(btn);
            }
        }

        function loadLayout(idx) {
            const layouts = JSON.parse(localStorage.getItem('hq_vault') || '[]');
            const data = layouts[idx];
            if (!data) return;

            // Use loadQuestData to restore EVERYTHING
            loadQuestData(data);

            toggleVault();
            // alert("Layout loaded!");
        }

        function deleteLayout(idx) {
            let layouts = JSON.parse(localStorage.getItem('hq_vault') || '[]');
            layouts.splice(idx, 1);
            localStorage.setItem('hq_vault', JSON.stringify(layouts));
            toggleVault(); toggleVault();
        }

        // --- QUEST GENERATION PLACEMENT LOGIC ---

        function identifyCustomRooms() {
            let rooms = [];
            const roomGroups = {};

            // Group spaces by their ID
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tile = customGrid[y][x];
                    if (tile && tile.type === 'room') {
                        if (!roomGroups[tile.id]) roomGroups[tile.id] = [];
                        roomGroups[tile.id].push({ x, y });
                    }
                }
            }

            // Convert groups into room objects
            let id = 1;
            for (const rid in roomGroups) {
                const spaces = roomGroups[rid];
                rooms.push({
                    roomNumber: id++,
                    spaces,
                    x: Math.min(...spaces.map(s => s.x)),
                    y: Math.min(...spaces.map(s => s.y)),
                    width: Math.max(...spaces.map(s => s.x)) - Math.min(...spaces.map(s => s.x)) + 1,
                    height: Math.max(...spaces.map(s => s.y)) - Math.min(...spaces.map(s => s.y)) + 1,
                    active: false
                });
            }
            return rooms;
        }

        function generateQuest() {
            if (isEditMode) return;
            currentQuest = quests[Math.floor(Math.random() * quests.length)];
            initializeGrid();

            let roomsToUse = [];
            if (useCustomLayout) {
                roomsToUse = identifyCustomRooms();
            } else {
                roomsToUse = ROOM_GROUPS.map(g => {
                    const roomSpaces = g.spaces.map(numberToCoords);
                    return {
                        roomNumber: g.roomNumber || g.number,
                        spaces: roomSpaces,
                        x: Math.min(...roomSpaces.map(s => s.x)),
                        y: Math.min(...roomSpaces.map(s => s.y)),
                        width: Math.max(...roomSpaces.map(s => s.x)) - Math.min(...roomSpaces.map(s => s.x)) + 1,
                        height: Math.max(...roomSpaces.map(s => s.y)) - Math.min(...roomSpaces.map(s => s.y)) + 1,
                        active: false
                    };
                });
            }

            setActiveRooms(roomsToUse);
			capCorridors(); 
            placeDoorsAndCorridors();
            placeFurniture();
            placeMonsters();
            placeTraps();
            initializePlayers();
			
			    // --- WANDERING MONSTER LOGIC ---
    // 1. Get all monsters currently on the board
    const boardMonsters = placedMonsters.map(pm => pm.type);
    
    // 2. Pick a random one from the board, or fallback to any monster if board is empty
    if (boardMonsters.length > 0) {
        // Use a Set to get unique types, then convert back to array
        const uniqueMonsters = [...new Set(boardMonsters.map(m => JSON.stringify(m)))].map(s => JSON.parse(s));
        currentQuest.wanderingMonster = uniqueMonsters[Math.floor(Math.random() * uniqueMonsters.length)];
    } else {
        // Fallback: Pick random from global list
        currentQuest.wanderingMonster = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
    }

            // POSITION LABELS: Hard check against occupied tiles
            activeRooms.forEach(room => {
                const clearSpaces = room.spaces.filter(s => {
                    // 1. Logical occupied check
                    if (grid[s.y][s.x].occupied) return false;

                    // 2. Extra safety: Check if any placed object shares this coordinate
                    const hasMonster = placedMonsters.some(m => m.x === s.x && m.y === s.y);
                    if (hasMonster) return false;

                    const hasFurniture = placedFurniture.some(f => {
                        const fp = getItemFootprint(f);
                        return s.x >= f.x && s.x < f.x + fp.w && s.y >= f.y && s.y < f.y + fp.h;
                    });
                    if (hasFurniture) return false;

                    return true;
                });

                if (clearSpaces.length > 0) {
                    clearSpaces.sort((a, b) => (a.y - b.y) || (a.x - b.x));
                    const spot = clearSpaces[Math.floor(Math.random() * clearSpaces.length)];
                    room.labelX = spot.x;
                    room.labelY = spot.y;
                } else {
                    room.labelX = room.x;
                    room.labelY = room.y;
                }
            });

            drawBoard();
            updateQuestUI();
        }

        function findCorridorPath(roomA, roomB) {
            let possibleExitsA = [];
            roomA.spaces.forEach(({ x, y }) => {
                const neighbors = [{ x: x - 1, y }, { x: x + 1, y }, { x, y: y - 1 }, { x, y: y + 1 }];
                neighbors.forEach(n => {
                    if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT && grid[n.y][n.x].type === 'corridor') {
                        possibleExitsA.push(n);
                    }
                });
            });

            let possibleEntrancesB = [];
            roomB.spaces.forEach(({ x, y }) => {
                const neighbors = [{ x: x - 1, y }, { x: x + 1, y }, { x, y: y - 1 }, { x, y: y + 1 }];
                neighbors.forEach(n => {
                    if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT && grid[n.y][n.x].type === 'corridor') {
                        possibleEntrancesB.push(n);
                    }
                });
            });

            for (let exitA of possibleExitsA) {
                for (let entranceB of possibleEntrancesB) {
                    let visited = new Set([`${exitA.x},${exitA.y}`]);
                    let queue = [{ x: exitA.x, y: exitA.y, path: [{ x: exitA.x, y: exitA.y }] }];
                    while (queue.length > 0) {
                        const { x, y, path } = queue.shift();
                        if (x === entranceB.x && y === entranceB.y) return path;
                        const neighbors = [{ x: x - 1, y }, { x: x + 1, y }, { x, y: y - 1 }, { x, y: y + 1 }];
                        for (let n of neighbors) {
                            if (n.x < 0 || n.x >= GRID_WIDTH || n.y < 0 || n.y >= GRID_HEIGHT) continue;
                            if (grid[n.y][n.x].type === 'corridor' && !visited.has(`${n.x},${n.y}`)) {
                                visited.add(`${n.x},${n.y}`);
                                queue.push({ x: n.x, y: n.y, path: [...path, n] });
                            }
                        }
                    }
                }
            }
            return null;
        }

function setActiveRooms(rooms) {
    activeRooms = [];

    // 1. Activate Quest Rooms
    let pool = [...rooms];
    currentQuest.rooms.forEach((qr) => {
        if (pool.length === 0) return;
        let idx = Math.floor(Math.random() * pool.length);
        let r = pool.splice(idx, 1)[0];
        r.active = true;
        r.letter = qr.letter;

        // Use the room's unique number as the ID
        const rID = r.roomNumber;

        r.spaces.forEach(s => {
            grid[s.y][s.x].active = true;
            grid[s.y][s.x].roomInstanceId = rID;
        });
        activeRooms.push(r);
    });

    // 2. Handle Corridor Activation
    if (useCustomLayout) {
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (grid[y][x].type === 'corridor') {
                    grid[y][x].active = true;
                    grid[y][x].roomInstanceId = 'corridor_global';
                }
            }
        }
    } else {
        // Classic pathfinding
        for (let i = 0; i < activeRooms.length - 1; i++) {
            const path = findCorridorPath(activeRooms[i], activeRooms[i + 1]);
            if (path) {
                path.forEach(step => {
                    grid[step.y][step.x].active = true;
                    grid[step.y][step.x].roomInstanceId = 'corridor_global';
                });
            }
        }
        
        // --- FIX: EXPAND CORRIDORS HERE ---
        // This ensures double-wide hallways are fully active
        expandCorridors(); 
    }
}
        function getItemFootprint(item) {
            let baseSize = { width: 1, height: 1 };

            if (item.furniture) {
                baseSize = item.furniture.size;
            } else if (item.type && item.type.size) {
                // This handles the new large monsters
                baseSize = item.type.size;
            } else if (item.wallData) {
                baseSize = item.wallData.size;
            }

            const isRotated = (item.facing % 2 !== 0);
            return {
                w: isRotated ? baseSize.height : baseSize.width,
                h: isRotated ? baseSize.width : baseSize.height
            };
        }

        function canPlaceItem(x, y, w, h, room) {
            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    const tx = x + dx;
                    const ty = y + dy;

                    // 1. Check Board Bounds
                    if (tx < 0 || tx >= GRID_WIDTH || ty < 0 || ty >= GRID_HEIGHT) return false;

                    // 2. Must be within the specific room's coordinate array
                    const inRoom = room.spaces.some(s => s.x === tx && s.y === ty);
                    if (!inRoom) return false;

                    // 3. Must not be occupied by another object or door path
                    if (grid[ty][tx].occupied) return false;
                }
            }
            return true;
        }

        function checkRoomConnectivity(room) {
            const emptyTiles = room.spaces.filter(s => !grid[s.y][s.x].occupied);
            if (emptyTiles.length === 0) return true;
            const start = emptyTiles[0];
            const visited = new Set();
            const queue = [start];
            visited.add(`${start.x},${start.y}`);
            let count = 0;
            while (queue.length > 0) {
                const curr = queue.shift();
                count++;
                [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                    const nx = curr.x + dx, ny = curr.y + dy;
                    const key = `${nx},${ny}`;
                    if (room.spaces.some(s => s.x === nx && s.y === ny) && !grid[ny][nx].occupied && !visited.has(key)) {
                        visited.add(key);
                        queue.push({ x: nx, y: ny });
                    }
                });
            }
            return count === emptyTiles.length;
        }

        function placeFurniture() {
            placedFurniture = [];
            activeRooms.forEach(room => {
                const questRoom = currentQuest.rooms.find(qr => qr.letter === room.letter);
                if (!questRoom) return;

                questRoom.furniture.forEach(f => {
                    const type = furnitureTypes.find(ft => ft.name === f.type);
                    let placed = false;
                    let attempts = 0;

                    while (!placed && attempts < 150) {
                        const space = room.spaces[Math.floor(Math.random() * room.spaces.length)];
                        // Randomize initial rotation for variety (0, 1, 2, or 3)
                        const facing = Math.floor(Math.random() * 4);

                        // Calculate footprint based on this rotation
                        const isRotated = (facing % 2 !== 0);
                        const w = isRotated ? type.size.height : type.size.width;
                        const h = isRotated ? type.size.width : type.size.height;

                        if (canPlaceItem(space.x, space.y, w, h, room)) {
                            // Temporarily mark as occupied to check connectivity
                            for (let i = 0; i < w; i++) for (let j = 0; j < h; j++) grid[space.y + j][space.x + i].occupied = true;

                            if (checkRoomConnectivity(room)) {
                                placedFurniture.push({ furniture: type, x: space.x, y: space.y, room: room, facing: facing });
                                placed = true;
                            } else {
                                // Unmark if it blocks the room
                                for (let i = 0; i < w; i++) for (let j = 0; j < h; j++) grid[space.y + j][space.x + i].occupied = false;
                            }
                        }
                        attempts++;
                    }
                });
            });
        }



        function toggleAssetPanel() {
            const panel = document.getElementById('assetLibrary');
            panel.style.display = panel.style.display === "none" ? "block" : "none";
            if (panel.style.display === "block") populateAssetLibrary();
        }

function populateAssetLibrary() {
    const mContainer = document.getElementById('monsterAssets');
    const fContainer = document.getElementById('furnitureAssets');
    const wContainer = document.getElementById('wallAssets');
    const tContainer = document.getElementById('trapAssets');
    const dContainer = document.getElementById('doorAssets');
    
    // 1. Create/Get Text Container (Insert after Doors)
    let textContainer = document.getElementById('textAssets');
    if (!textContainer) {
        textContainer = document.createElement('div');
        textContainer.id = 'textAssets';
        // Append to main list
        document.getElementById('assetLibrary').appendChild(textContainer);
    }

    // 2. Create/Get Room Label Container (Insert after Text)
    let lContainer = document.getElementById('labelAssets');
    if (!lContainer) {
        lContainer = document.createElement('div');
        lContainer.id = 'labelAssets';
        document.getElementById('assetLibrary').appendChild(lContainer);
    }

    if (!mContainer || !fContainer || !wContainer || !tContainer || !dContainer) return;

    // --- STANDARD ASSETS ---
    mContainer.innerHTML = '<h4>Monsters</h4>';
    monsterTypes.forEach(m => { mContainer.innerHTML += `<img src="${m.imageUrl}" onclick="spawnAsset('monster', '${m.name}')" class="asset-icon" title="${m.name}">`; });

    fContainer.innerHTML = '<h4>Furniture</h4>';
    furnitureTypes.forEach(f => { fContainer.innerHTML += `<img src="${f.imageUrl}" onclick="spawnAsset('furniture', '${f.name}')" class="asset-icon" title="${f.name}">`; });

    wContainer.innerHTML = '<h4>Walls</h4>';
    wallTypes.forEach(w => { wContainer.innerHTML += `<img src="${w.imageUrl}" onclick="spawnAsset('wall', '${w.name}')" class="asset-icon" title="${w.name}">`; });

    tContainer.innerHTML = '<h4>Traps</h4>';
    trapTypes.forEach(t => { tContainer.innerHTML += `<img src="${t.imageUrl}" onclick="spawnAsset('trap', '${t.name}')" class="asset-icon" title="${t.name}">`; });

    dContainer.innerHTML = '<h4>Doors</h4>';
    dContainer.innerHTML += `<img src="${DOOR_IMAGES['Door1x1']}" onclick="spawnAsset('door', 'Door1x1')" class="asset-icon" title="Standard Door">`;
    dContainer.innerHTML += `<img src="${DOOR_IMAGES['SecretDoor']}" onclick="spawnAsset('door', 'SecretDoor')" class="asset-icon" title="Secret Door">`;

    // --- NEW: TEXT SECTION ---
    textContainer.innerHTML = '<h4>Text & Annotations</h4>';
    
    // "T" Icon
    const tIcon = document.createElement('canvas');
    tIcon.width = 50; tIcon.height = 50;
    const ctxT = tIcon.getContext('2d');
    ctxT.fillStyle = "#fff"; ctxT.fillRect(0,0,50,50);
    ctxT.strokeStyle = "#333"; ctxT.lineWidth=2; ctxT.strokeRect(2,2,46,46);
    ctxT.fillStyle = "#333"; ctxT.font = "bold 30px Arial"; 
    ctxT.textAlign = "center"; ctxT.textBaseline = "middle";
    ctxT.fillText("T", 25, 25);

    const txtBtn = document.createElement('img');
    txtBtn.src = tIcon.toDataURL();
    txtBtn.className = 'asset-icon';
    txtBtn.title = "Text Box / Label";
    txtBtn.onclick = () => spawnAsset('text', 'New Text');
    
    textContainer.appendChild(txtBtn);

    // --- ROOM LABELS SECTION ---
    lContainer.innerHTML = '<h4>Room Labels</h4>';
    const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
    letters.forEach(char => {
        const c = document.createElement('canvas');
        c.width = 40; c.height = 40;
        const x = c.getContext('2d');
        x.fillStyle = "#fff"; x.fillRect(0,0,40,40);
        x.strokeStyle = "#ccc"; x.strokeRect(0,0,40,40);
        x.fillStyle = "#b22222"; x.font = "bold 24px Arial"; 
        x.textAlign = "center"; x.textBaseline = "middle";
        x.fillText(char, 20, 20);
        
        const img = document.createElement('img');
        img.src = c.toDataURL();
        img.className = 'asset-icon';
        img.onclick = () => spawnAsset('label', char);
        img.title = "Room " + char;
        lContainer.appendChild(img);
    });
}
		
		function openWanderingMonsterPicker() {
    // Only allow changing if we are in Edit Mode
    if (!isQuestEditMode) {
        alert("Please enter Editor Mode to change the Wandering Monster.");
        return;
    }

    const modal = document.getElementById('wmModal');
    const overlay = document.getElementById('overlay');
    const gridDiv = document.getElementById('wmGrid');
    
    // Populate Grid
    gridDiv.innerHTML = '';
    monsterTypes.forEach(m => {
        const div = document.createElement('div');
        div.style.cssText = "text-align:center; cursor:pointer; padding:5px; border:1px solid #eee; border-radius:4px;";
        div.onmouseover = () => div.style.borderColor = "#673ab7";
        div.onmouseout = () => div.style.borderColor = "#eee";
        div.onclick = () => selectWanderingMonster(m.name);
        
        div.innerHTML = `
            <img src="${m.imageUrl}" style="width:40px; height:40px; object-fit:contain;">
            <div style="font-size:10px; margin-top:2px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${m.name}</div>
        `;
        gridDiv.appendChild(div);
    });

    modal.style.display = 'block';
    overlay.style.display = 'block';
}

// --- TEXT EDITOR LOGIC ---

function showTextEditor(item) {
    editingTextItem = item;
    const toolbar = document.getElementById('textEditorToolbar');
    const tilePanel = document.getElementById('tileSidePanel'); // Get the Tile Library panel
    const input = document.getElementById('textLabelInput');
    const size = document.getElementById('textSizeInput');
    const color = document.getElementById('textColorInput');

    // Populate values
    input.value = item.text;
    size.value = item.fontSize || 16;
    color.value = item.color || "#000000";

    // --- DYNAMIC POSITIONING ---
    if (tilePanel && tilePanel.style.display !== 'none') {
        // Get position of the Tile Library
        const rect = tilePanel.getBoundingClientRect();
        
        toolbar.style.position = 'fixed';
        // Set Top to (TilePanel Bottom + 10px padding)
        toolbar.style.top = (rect.bottom + 10) + 'px';
        // Match Left alignment
        toolbar.style.left = rect.left + 'px';
        // Clear conflicting bottom property
        toolbar.style.bottom = 'auto';
    } else {
        // Fallback if panel isn't visible (e.g., specific edit mode states)
        toolbar.style.top = '150px';
        toolbar.style.left = '20px';
        toolbar.style.bottom = 'auto';
    }

    toolbar.style.display = 'block';
    
    drawBoard(); 
}

function updateActiveTextLabel() {
    if (!editingTextItem) return;
    editingTextItem.text = document.getElementById('textLabelInput').value;
    editingTextItem.fontSize = parseInt(document.getElementById('textSizeInput').value);
    editingTextItem.color = document.getElementById('textColorInput').value;
    drawBoard();
}

function setTextArrow(dir) {
    if (editingTextItem) {
        editingTextItem.arrow = dir;
        drawBoard();
    }
}

function deleteActiveTextLabel() {
    if (editingTextItem) {
        placedTexts = placedTexts.filter(t => t !== editingTextItem);
        closeTextEditor();
        drawBoard();
    }
}

function closeTextEditor() {
    document.getElementById('textEditorToolbar').style.display = 'none';
    editingTextItem = null;
    drawBoard();
}

function selectWanderingMonster(monsterName) {
    const m = monsterTypes.find(x => x.name === monsterName);
    if (m && currentQuest) {
        currentQuest.wanderingMonster = m;
        updateQuestUI(); // Re-render the bottom section
        
        // Close modal
        document.getElementById('wmModal').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
    }
}

// 1. New Toggle Function (Replaces toggleMapMakerMode and toggleQuestEditMode)
function toggleUnifiedEditMode() {
    // We use isEditMode as the primary flag, but set both to true/false
    const newMode = !isEditMode; 
    
    isEditMode = newMode;
    isQuestEditMode = newMode; // Enable both Painting AND Dragging

    const btn = document.getElementById('unifiedEditBtn');
    const leftPanel = document.getElementById('tileSidePanel');
    const rightPanel = document.getElementById('assetLibrary');
    const toolbar = document.getElementById('mapMakerToolbar');

    if (newMode) {
        // --- ENTERING EDITOR ---
        btn.innerText = "Exit Editor Mode";
        btn.style.background = "#f44336"; // Red to indicate 'active/stop'

        // Show BOTH panels
        leftPanel.style.display = 'block';
        rightPanel.style.display = 'block';
        toolbar.style.display = 'flex';

        // Initialize Asset Library
        populateAssetLibrary();

        // IMPORT CURRENT MAP to Custom Grid (Logic from old toggleMapMakerMode)
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const cell = grid[y][x];
                if (cell.active) {
                    customGrid[y][x] = {
                        type: cell.type,
                        id: cell.roomInstanceId,
                        isPaintedRoom: cell.type === 'room'
                    };
                } else {
                    customGrid[y][x] = null;
                }
            }
        }
        
        // Show the Map Maker tracing layer
        drawEditor();

    } else {
        // --- EXITING EDITOR ---
        btn.innerText = "Enter Editor Mode";
        btn.style.background = "#4CAF50"; // Green/Default

        // Hide Panels
        leftPanel.style.display = 'none';
        rightPanel.style.display = 'none';
        toolbar.style.display = 'none';

        // EXPORT Custom Grid back to Live Map
        useCustomLayout = true; // Force custom layout usage
        
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const source = customGrid[y][x];
                grid[y][x].active = !!source;
                grid[y][x].type = source ? source.type : 'empty';
                grid[y][x].roomInstanceId = source ? source.id : null;
            }
        }

        // Clean up UI
        rebuildOccupancy();
        updateQuestUI();
        drawBoard();
    }
}

// 2. MODIFIED spawnAsset (Prevent closing panel)
function spawnAsset(type, name) {
    // Default to mouse position
    let spawnX = mousePos.x;
    let spawnY = mousePos.y;

    // FIX: Force Text Box to spawn in the dead center of the screen
    // because clicking the sidebar button usually puts mousePos off-grid.
    if (type === 'text') {
        spawnX = Math.floor(GRID_WIDTH / 2) - 1; // Center X (approx 12)
        spawnY = Math.floor(GRID_HEIGHT / 2);    // Center Y (approx 9)
    }

    let newItem = { x: spawnX, y: spawnY, facing: 0, type_id: type };

    if (type === 'text') {
        // Initialize Text Object
        newItem.text = "Label";
        newItem.width = 3;      // Default width
        newItem.height = 1;     // Default height
        newItem.fontSize = 16;
        newItem.color = "#000000";
        newItem.arrow = 'none'; 
        newItem.rotation = 0;   
        
        placedTexts.push(newItem);
        
        // Immediately select for editing, but DO NOT start dragging.
        // It will sit in the center of the map until you move it.
        editingTextItem = newItem;
        showTextEditor(newItem);
        draggedItem = null; 
    }
    else if (type === 'label') {
        newItem.letter = name;
        // Labels stick to mouse immediately, so X/Y doesn't matter as much (updates on mousemove)
    }
    else if (type === 'monster') {
        newItem.type = monsterTypes.find(m => m.name === name);
        placedMonsters.push(newItem);
    } 
    else if (type === 'furniture') {
        newItem.furniture = furnitureTypes.find(f => f.name === name);
        placedFurniture.push(newItem);
    } 
    else if (type === 'wall') { 
        newItem.wallData = wallTypes.find(w => w.name === name);
        manualWalls.push(newItem);
    } 
    else if (type === 'trap') {
        newItem.type = name;
        placedTraps.push(newItem);
    } 
    else if (type === 'door') {
        newItem.secret = (name === 'SecretDoor');
        newItem.revealed = true;
        newItem.x = spawnX;
        newItem.y = spawnY - 0.5;
        doors.push(newItem);
    }

    // Set Drag State (Everything except Text drags immediately on spawn)
    if (type !== 'text') {
        draggedItem = newItem;
        dragOffset = { x: 0, y: 0 };
    }

    // Reset Map Maker brush
    selectedBrush.type = null; 
    document.querySelectorAll('#tileSidePanel .tile-option').forEach(el => el.classList.remove('selected'));
    
    drawBoard();
}

// 3. UPDATED selectBrush (To handle visual selection clearing)
function selectBrush(type, w, h) {
    // If type is null, we are in "Move Mode"
    selectedBrush = { type, w, h, rot: 0 };
    document.getElementById('rotVal').innerText = "0";

    // Visual Updates
    document.querySelectorAll('#tileSidePanel .tile-option').forEach(el => el.classList.remove('selected'));
    
    if (window.event && type !== null) {
        window.event.currentTarget.classList.add('selected');
    }
    
    // If we are selecting a brush, we stop dragging any items
    draggedItem = null;
    drawEditor();
}

        // --- UPDATED MOUSE WHEEL FOR ROTATION ---
        canvas.addEventListener('wheel', (e) => {
            if (!isQuestEditMode || !draggedItem) return;
            e.preventDefault();

            // Rotate 90 degrees
            const dir = e.deltaY > 0 ? 1 : -1;
            draggedItem.facing = (draggedItem.facing + dir + 4) % 4;

            // Special logic for multi-tile furniture: swap W/H visually
            if (draggedItem.type_id === 'furniture') {
                const f = draggedItem.furniture;
                // Logic handled in drawBoard using f.facing
            }
            drawBoard();
        });

        // --- UPDATED MOUSE MOVE FOR BETTER DRAG SNAP ---
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const rawX = (e.clientX - rect.left) * scaleX;
    const rawY = (e.clientY - rect.top) * scaleY;
    const mx = rawX / SPACE_WIDTH;
    const my = rawY / SPACE_HEIGHT;

    // Global integer grid pos
    mousePos.x = Math.floor(mx);
    mousePos.y = Math.floor(my);

    // 1. Text Manipulation (Resize / Rotate)
    if (isQuestEditMode && editingTextItem && resizeHandle) {
        const t = editingTextItem;
        
        if (resizeHandle === 'br') {
            // Resize (min size 1x0.5 tiles)
            t.width = Math.max(1, mx - t.x);
            t.height = Math.max(0.5, my - t.y);
        } else if (resizeHandle === 'rot') {
            // Rotation
            const cx = (t.x + t.width/2) * SPACE_WIDTH;
            const cy = (t.y + t.height/2) * SPACE_HEIGHT;
            const angle = Math.atan2(rawY - cy, rawX - cx);
            t.rotation = (angle * 180 / Math.PI) + 90; // +90 aligns handle to top
        }
        drawBoard();
        return; // Skip other dragging logic
    }

    // 2. Dragging Items
    if (isQuestEditMode && draggedItem) {
        // A. TEXT BOX (Float Drag)
        if (draggedItem.type_id === 'text') {
            draggedItem.x = mx - dragOffset.x;
            draggedItem.y = my - dragOffset.y;
        } 
        // B. DOORS (Line Snap)
        else if (draggedItem.type_id === 'door') {
            if (draggedItem.facing % 2 === 0) {
                draggedItem.x = Math.floor(mx);
                draggedItem.y = Math.floor(my + 0.5) - 0.5;
            } else {
                draggedItem.x = Math.floor(mx + 0.5) - 0.5;
                draggedItem.y = Math.floor(my);
            }
        } 
        // C. MULTI-TILE (Offset Snap)
        else if (draggedItem.type_id === 'furniture' || draggedItem.type_id === 'wall') {
            draggedItem.x = Math.floor(mx) - dragOffset.x;
            draggedItem.y = Math.floor(my) - dragOffset.y;
        } 
        // D. LABELS (Tile Snap)
        else if (draggedItem.type_id === 'label') {
            draggedItem.x = Math.floor(mx);
            draggedItem.y = Math.floor(my);
        } 
        // E. MONSTERS/TRAPS (Simple Snap)
        else {
            draggedItem.x = Math.floor(mx);
            draggedItem.y = Math.floor(my);
        }

        drawBoard();
    }

    // 3. Map Painting Ghost
    else if (isEditMode) {
        if (selectedBrush && selectedBrush.type) {
            drawEditor();
        } else {
            drawBoard();
        }
    }
});

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX / SPACE_WIDTH;
            const my = (e.clientY - rect.top) * scaleY / SPACE_HEIGHT;
            const gx = Math.floor(mx);
            const gy = Math.floor(my);

            // --- MIDDLE MOUSE CLICK: CANCEL ---
            if (e.button === 1) {
                e.preventDefault();
                if (isEditMode) selectedBrush.type = null;
                else if (isQuestEditMode && draggedItem) draggedItem = null;
                drawEditor();
                drawBoard();
                return;
            }

            // --- MODE 1: MAP MAKER (Painting Rooms/Corridors) ---
            if (isEditMode) {
                if (e.button === 0 && selectedBrush.type) { // Left click: Place
                    const { w, h, rot, type } = selectedBrush;
                    const actualW = (rot === 90 || rot === 270) ? h : w;
                    const actualH = (rot === 90 || rot === 270) ? w : h;

                    let currentID;

                    if (type === 'room') {
                        if (w === 1 && h === 1) {
                            // 1x1 Room Logic: Check neighbors for an existing 1x1 room ID to merge with
                            const neighbors = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                            let foundNeighborID = null;
                            for (let [dx, dy] of neighbors) {
                                let nx = gx + dx, ny = gy + dy;
                                if (customGrid[ny] && customGrid[ny][nx] && customGrid[ny][nx].isPaintedRoom) {
                                    foundNeighborID = customGrid[ny][nx].id;
                                    break;
                                }
                            }
                            currentID = foundNeighborID || `painted_${roomInstanceCounter++}`;
                        } else {
                            // Prefab Room Logic: Unique ID for this specific placement
                            currentID = `room_${roomInstanceCounter++}`;
                        }
                    } else {
                        currentID = 'corridor_global';
                    }

                    for (let dy = 0; dy < actualH; dy++) {
                        for (let dx = 0; dx < actualW; dx++) {
                            let tx = gx + dx, ty = gy + dy;
                            if (tx >= 0 && tx < GRID_WIDTH && ty >= 0 && ty < GRID_HEIGHT) {
                                customGrid[ty][tx] = {
                                    type: type,
                                    id: currentID,
                                    isPaintedRoom: (type === 'room' && w === 1 && h === 1)
                                };
                            }
                        }
                    }
                } else if (e.button === 2) { // Right click: Erase
                    e.preventDefault();
                    if (gx >= 0 && gx < GRID_WIDTH && gy >= 0 && gy < GRID_HEIGHT) {
                        customGrid[gy][gx] = null;
                    }
                }
                drawEditor();
                return;
            }

            // --- MODE 2: QUEST EDITOR (Dragging/Deleting monsters/furniture) ---
            if (isQuestEditMode) {
                const monsterIdx = placedMonsters.findIndex(m => m.x === gx && m.y === gy);
                const furnitureIdx = placedFurniture.findIndex(f => {
                    const fp = getItemFootprint(f);
                    return gx >= f.x && gx < f.x + fp.w && gy >= f.y && gy < f.y + fp.h;
                });
                const wallIdx = manualWalls.findIndex(w => {
                    const fp = getItemFootprint(w);
                    return gx >= w.x && gx < w.x + fp.w && gy >= w.y && gy < w.y + fp.h;
                });
                const trapIdx = placedTraps.findIndex(t => t.x === gx && t.y === gy);
                const doorIdx = doors.findIndex(d => {
                    const thresholdX = d.secret ? 0.8 : 0.6;
                    const thresholdY = d.secret ? 1.2 : 0.6;
                    return Math.abs(d.x - (mx - 0.5)) < thresholdX && Math.abs(d.y - (my - 0.5)) < thresholdY;
                });

                if (e.button === 2) { // Right Click: Delete
                    e.preventDefault();
                    if (monsterIdx !== -1) placedMonsters.splice(monsterIdx, 1);
                    else if (furnitureIdx !== -1) placedFurniture.splice(furnitureIdx, 1);
                    else if (wallIdx !== -1) manualWalls.splice(wallIdx, 1);
                    else if (trapIdx !== -1) placedTraps.splice(trapIdx, 1);
                    else if (doorIdx !== -1) doors.splice(doorIdx, 1);
                    rebuildOccupancy();
                    drawBoard();
                    return;
                }

                if (e.button === 0) { // Left Click: Drag
                    if (monsterIdx !== -1) { draggedItem = placedMonsters[monsterIdx]; draggedItem.type_id = 'monster'; }
                    else if (furnitureIdx !== -1) {
                        draggedItem = placedFurniture[furnitureIdx]; draggedItem.type_id = 'furniture';
                        dragOffset = { x: gx - draggedItem.x, y: gy - draggedItem.y };
                    }
                    else if (wallIdx !== -1) {
                        draggedItem = manualWalls[wallIdx]; draggedItem.type_id = 'wall';
                        dragOffset = { x: gx - draggedItem.x, y: gy - draggedItem.y };
                    }
                    else if (doorIdx !== -1) { draggedItem = doors[doorIdx]; draggedItem.type_id = 'door'; }
                    else if (trapIdx !== -1) { draggedItem = placedTraps[trapIdx]; draggedItem.type_id = 'trap'; }
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isQuestEditMode || !draggedItem) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const mx = (e.clientX - rect.left) * scaleX / SPACE_WIDTH;
            const my = (e.clientY - rect.top) * scaleY / SPACE_HEIGHT;

            if (draggedItem.type_id === 'door') {
                // Doors snap to 0.5 increments
                draggedItem.x = Math.floor(mx) + (draggedItem.facing % 2 === 0 ? 0 : -0.5);
                draggedItem.y = Math.floor(my) + (draggedItem.facing % 2 === 0 ? -0.5 : 0);
            } else if (draggedItem.type_id === 'furniture') {
                draggedItem.x = Math.floor(mx) - dragOffset.x;
                draggedItem.y = Math.floor(my) - dragOffset.y;
            } else {
                draggedItem.x = Math.floor(mx);
                draggedItem.y = Math.floor(my);
            }
            drawBoard();
        });

canvas.addEventListener('mouseup', () => {
    resizeHandle = null; // Stop text resizing

    if (draggedItem) {
        
        // --- LABEL DROP LOGIC (Create Room) ---
        if (draggedItem.type_id === 'label') {
            const gx = Math.floor(mousePos.x); 
            const gy = Math.floor(mousePos.y);
            
            if (gx >= 0 && gx < GRID_WIDTH && gy >= 0 && gy < GRID_HEIGHT) {
                // Check if Active Room exists
                let targetRoom = activeRooms.find(r => 
                    r.spaces.some(s => s.x === gx && s.y === gy)
                );

                // If not, try to create one from painted customGrid
                if (!targetRoom && customGrid[gy][gx] && customGrid[gy][gx].type === 'room') {
                    const newId = 900 + activeRooms.length;
                    targetRoom = {
                        roomNumber: newId,
                        letter: '', 
                        spaces: [],
                        active: true,
                        flavor: "Enter room description...",
                        name: "Custom Room"
                    };

                    // Flood Fill logic to get room shape
                    const startId = customGrid[gy][gx].id;
                    const openList = [{x: gx, y: gy}];
                    const visited = new Set();
                    visited.add(`${gx},${gy}`);

                    while(openList.length > 0) {
                        const current = openList.pop();
                        targetRoom.spaces.push({x: current.x, y: current.y});

                        // Activate Live Grid
                        if (grid[current.y][current.x]) {
                            grid[current.y][current.x].active = true;
                            grid[current.y][current.x].type = 'room';
                            grid[current.y][current.x].roomInstanceId = newId;
                            grid[current.y][current.x].occupied = false; 
                        }

                        // Neighbors
                        const neighbors = [
                            {x: current.x+1, y: current.y}, {x: current.x-1, y: current.y},
                            {x: current.x, y: current.y+1}, {x: current.x, y: current.y-1}
                        ];
                        neighbors.forEach(n => {
                            if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT) {
                                const key = `${n.x},${n.y}`;
                                if (!visited.has(key)) {
                                    const tile = customGrid[n.y][n.x];
                                    if (tile && tile.type === 'room' && tile.id === startId) {
                                        visited.add(key);
                                        openList.push(n);
                                    }
                                }
                            }
                        });
                    }
                    
                    // Bounds
                    const xs = targetRoom.spaces.map(s => s.x);
                    const ys = targetRoom.spaces.map(s => s.y);
                    targetRoom.x = Math.min(...xs);
                    targetRoom.y = Math.min(...ys);
                    targetRoom.width = Math.max(...xs) - targetRoom.x + 1;
                    targetRoom.height = Math.max(...ys) - targetRoom.y + 1;
                    
                    activeRooms.push(targetRoom);
                }

                // Apply Letter
                if (targetRoom) {
                    const dupe = activeRooms.find(r => r.letter === draggedItem.letter);
                    if (dupe) dupe.letter = ''; // Steal letter if duplicate

                    targetRoom.letter = draggedItem.letter;
                    targetRoom.labelX = gx;
                    targetRoom.labelY = gy;
                    
                    updateQuestUI();
                }
            }
        }

        // Stop dragging text
        if (draggedItem.type_id === 'text') {
            draggedItem = null;
            return;
        }

        draggedItem = null;
        rebuildOccupancy();
        drawBoard();
    }
});
        function rebuildOccupancy() {
            // 1. Reset logical occupancy
            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) grid[y][x].occupied = false;
            }

            // 2. Mark all items on the grid
            const allItems = [...placedFurniture, ...placedMonsters, ...placedTraps, ...manualWalls];
            allItems.forEach(item => {
                // Find which room the object is now sitting in for Quest Notes logic
                const currentRoom = activeRooms.find(r =>
                    r.spaces.some(s => s.x === Math.floor(item.x) && s.y === Math.floor(item.y))
                );
                item.room = currentRoom;

                // Lock the logical grid spaces
                const fp = getItemFootprint(item);
                for (let i = 0; i < fp.w; i++) {
                    for (let j = 0; j < fp.h; j++) {
                        let tx = item.x + i, ty = item.y + j;
                        if (grid[ty] && grid[ty][tx]) grid[ty][tx].occupied = true;
                    }
                }
            });

            // 3. Lock Door spaces (Entry/Exit tiles)
            doors.forEach(d => {
                const cx = Math.floor(d.x + 0.5);
                const cy = Math.floor(d.y + 0.5);
                if (grid[cy] && grid[cy][cx]) grid[cy][cx].occupied = true;
            });
        }

        function placeMonsters() {
            placedMonsters = [];
            activeRooms.forEach(room => {
                const questRoom = currentQuest.rooms.find(qr => qr.letter === room.letter);
                if (!questRoom) return;
                questRoom.monsters.forEach(m => {
                    const type = monsterTypes.find(mt => mt.name === m.type);
                    for (let i = 0; i < m.count; i++) {
                        let attempts = 0;
                        while (attempts < 30) {
                            const space = room.spaces[Math.floor(Math.random() * room.spaces.length)];
                            // Check if the tile is free of other monsters AND door paths
                            if (!grid[space.y][space.x].occupied) {
                                placedMonsters.push({ type: type, x: space.x, y: space.y, room: room });
                                grid[space.y][space.x].occupied = true;
                                break;
                            }
                            attempts++;
                        }
                    }
                });
            });
        }

        function placeTraps() {
            placedTraps = [];
            activeRooms.forEach(room => {
                const questRoom = currentQuest.rooms.find(qr => qr.letter === room.letter);
                if (!questRoom || !questRoom.traps) return;
                questRoom.traps.forEach(t => {
                    for (let i = 0; i < (t.count || 1); i++) {
                        const availableSpaces = room.spaces.filter(s => !grid[s.y][s.x].occupied);
                        if (availableSpaces.length > 0) {
                            const space = availableSpaces[Math.floor(Math.random() * availableSpaces.length)];
                            placedTraps.push({ type: t.type, x: space.x, y: space.y, room: room });
                            grid[space.y][space.x].occupied = true; // Lock tile for traps too
                        }
                    }
                });
            });
        }

        function initializePlayers() {
            const stair = placedFurniture.find(f => f.furniture.name === 'Staircase');
            if (stair) {
                players = [
                    { x: stair.x, y: stair.y },
                    { x: stair.x + 1, y: stair.y },
                    { x: stair.x, y: stair.y + 1 },
                    { x: stair.x + 1, y: stair.y + 1 }
                ];
            } else if (activeRooms.length > 0) {
                players = [{ x: activeRooms[0].x, y: activeRooms[0].y }];
            }
        }

        function downloadQuest(format) {
            const exportArea = document.getElementById('exportArea');

            html2canvas(exportArea, {
                scale: 2,
                useCORS: true,
                logging: true,
                backgroundColor: null,
                onclone: (clonedDoc) => {
                    // FIX: "Blank Map" issue on local file:// due to tainted canvas.
                    // We manually reconstruct the map using DOM elements in the cloned document.
                    // SCREENSHOT STRATEGY:
                    // Capture the live canvas (which looks correct) and output IT as the map.
                    const canvas = document.getElementById('gameCanvas');
                    let canvasImgData = null;
                    try {
                        canvasImgData = canvas.toDataURL("image/png");
                    } catch (e) {
                        console.error("Canvas Tainted", e);
                        alert("Cannot export map: Security Error (CORS). Some images (monsters/furniture) might be from a restricted source.");
                        return; // Abort
                    }

                    const cContainer = clonedDoc.getElementById('gameContainer');
                    const cCanvas = clonedDoc.getElementById('gameCanvas');

                    if (cContainer && cCanvas && canvasImgData) {
                        // Remove the original canvas (which is empty/tainted in the clone)
                        cCanvas.remove();

                        // Create the snapshot image
                        const img = clonedDoc.createElement('img');
                        img.src = canvasImgData;

                        // Style to match the canvas overlay position
                        // Assuming canvas was overlaying the background image.
                        // We set it to absolute to be safe + zIndex? 
                        // Actually, looking at the DOM (Line 506), they are siblings.
                        // Img first, Canvas second.
                        // We'll insert the snapshot where the canvas was.
                        img.style.position = 'absolute';
                        img.style.top = '0';
                        img.style.left = '0';
                        img.style.zIndex = '5'; // Ensure above background

                        // Fix for container usually being 'relative'
                        if (getComputedStyle(cContainer).position === 'static') {
                            cContainer.style.position = 'relative';
                        }

                        cContainer.appendChild(img);
                    }
                }
            }).then(canvasExport => {
                const fileName = (currentQuest ? currentQuest.name : 'HeroQuest_Quest').replace(/\s+/g, '_');

                if (format === 'png') {
                    const link = document.createElement('a');
                    link.download = `${fileName}.png`;
                    link.href = canvasExport.toDataURL('image/png');
                    link.click();
                } else if (format === 'pdf') {
                    const imgData = canvasExport.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;

                    const pdf = new jsPDF('p', 'mm', 'a4');
                    const pageWidth = 210;
                    const pageHeight = 297;
                    const margin = 10;
                    const maxWidth = pageWidth - (margin * 2);
                    const maxHeight = pageHeight - (margin * 2);

                    let finalWidth = maxWidth;
                    let finalHeight = (canvasExport.height * finalWidth) / canvasExport.width;

                    if (finalHeight > maxHeight) {
                        finalHeight = maxHeight;
                        finalWidth = (canvasExport.width * finalHeight) / canvasExport.height;
                    }

                    const xOffset = (pageWidth - finalWidth) / 2;
                    pdf.addImage(imgData, 'PNG', xOffset, margin, finalWidth, finalHeight);
                    pdf.save(`${fileName}.pdf`);
                }
            });
        }

        function updateQuestData(field, value) {
            if (currentQuest) currentQuest[field] = value;
        }

function updateRoomData(roomLetter, field, value) {
    // 1. Update the Active Room (The one on the board)
    // We search by letter, or if that fails, we might need a backup strategy, 
    // but the UI only passes valid letters.
    const activeRoom = activeRooms.find(r => r.letter === roomLetter);
    if (activeRoom) {
        activeRoom[field] = value;
    }

    // 2. Update the Quest Definition (The save file structure)
    if (currentQuest && currentQuest.rooms) {
        const questRoom = currentQuest.rooms.find(qr => qr.letter === roomLetter);
        if (questRoom) {
            questRoom[field] = value;
        } else if (activeRoom) {
            // If it's a custom room not in the original quest definition, add it
            // This ensures custom rooms save their descriptions too
            currentQuest.rooms.push({
                letter: roomLetter,
                name: activeRoom.name || "Custom Room",
                [field]: value
            });
        }
    }
}

function updateQuestUI() {
    if (!currentQuest) return;

    // 1. QUEST HEADER
    const objective = questObjectives.find(q => q.name === currentQuest.name) || { objective: "Unknown" };
    const headerHtml = `
        <h2 contenteditable="true" onblur="updateQuestData('name', this.innerText)" style="margin-top:0;">${currentQuest.name}</h2>
        <p class="flavor" contenteditable="true" onblur="updateQuestData('flavor', this.innerText)" style="font-style:italic; color:#555;">${currentQuest.flavor || "No flavor text available."}</p>
        <p><strong>Goal:</strong> <span contenteditable="true" onblur="updateQuestData('goal', this.innerText)">${currentQuest.goal || objective.objective}</span></p>
        <p><strong>Rewards:</strong> <span contenteditable="true" onblur="updateQuestData('rewards', this.innerText)">${currentQuest.rewards || 'None'}</span></p>
    `;
    document.getElementById('questInfo').innerHTML = headerHtml;

    // 2. ROOM NOTES
    const sortedRooms = [...activeRooms].sort((a, b) => (a.letter || 'ZZ').localeCompare(b.letter || 'ZZ'));

    let roomHtml = sortedRooms.map(activeRoom => {
        if (!activeRoom.letter) return '';

        const def = currentQuest.rooms.find(r => r.letter === activeRoom.letter) || {};
        const rName = activeRoom.name || def.name || "Unnamed Room";
        const rFlavor = activeRoom.flavor || def.flavor || "Enter room description...";

        // Count Contents
        const monsters = placedMonsters.filter(m => m.room === activeRoom);
        const monsterCounts = monsters.reduce((acc, m) => {
            const name = m.type.name || m.type;
            acc[name] = (acc[name] || 0) + 1;
            return acc;
        }, {});

        const monsterHTML = Object.entries(monsterCounts).map(([name, count]) => {
            const type = monsterTypes.find(t => t.name === name);
            const imgUrl = type ? type.imageUrl : '';
            return `<div style="display:inline-block; margin-right:15px; margin-bottom:5px;">
                        <img src="${imgUrl}" class="monster-image" style="width:30px; height:30px; object-fit:contain; vertical-align:middle;"> 
                        <strong>${count}</strong> ${name}
                    </div>`;
        }).join('') || '<span style="color:#999;">None</span>';

        const furniture = placedFurniture.filter(f => f.room === activeRoom);
        const furnitureCounts = furniture.reduce((acc, f) => {
            const name = f.furniture.name;
            acc[name] = (acc[name] || 0) + 1;
            return acc;
        }, {});
        const furnitureHTML = Object.entries(furnitureCounts).map(([name, count]) => `${count} ${name}`).join(', ') || '<span style="color:#999;">None</span>';

        const traps = placedTraps.filter(t => t.room === activeRoom);
        const trapCounts = traps.reduce((acc, t) => {
            const name = (typeof t.type === 'string') ? t.type : t.type.name;
            acc[name] = (acc[name] || 0) + 1;
            return acc;
        }, {});
        const trapHTML = Object.entries(trapCounts).map(([name, count]) => `${count} ${name}`).join(', ') || '<span style="color:#999;">None</span>';

        // Render Card
        return `<div class="room-section">
            <h4 style="margin:0 0 10px 0; color:#b22222; border-bottom:1px solid #eee; padding-bottom:5px;">
                Room ${activeRoom.letter} - 
                <span contenteditable="true" 
                      style="color:#333; cursor:text; border-bottom:1px dashed #ccc;"
                      onblur="updateRoomData('${activeRoom.letter}', 'name', this.innerText)"
                      title="Click to edit room name">
                      ${rName}
                </span>
            </h4>
            <div style="margin-bottom:5px;"><strong>Monsters:</strong><br> ${monsterHTML}</div>
            <div style="margin-bottom:5px;"><strong>Furniture:</strong> ${furnitureHTML}</div>
            <div style="margin-bottom:5px;"><strong>Traps:</strong> ${trapHTML}</div>
            
            <p style="font-size:0.9em; border-top:1px dashed #ccc; padding-top:5px; margin-top:5px; font-style:italic; color:#444;"
               contenteditable="true"
               onblur="updateRoomData('${activeRoom.letter}', 'flavor', this.innerText)"
               title="Click to edit flavor text">
               ${rFlavor}
            </p>
        </div>`;
    }).join('');

    // 3. WANDERING MONSTER (With extra bottom spacing)
    let wmHtml = '';
    if (currentQuest.wanderingMonster) {
        const wm = currentQuest.wanderingMonster;
        const hintText = isQuestEditMode ? '(Click to Change)' : '';
        const hoverStyle = isQuestEditMode ? 'cursor:pointer; opacity: 0.9;' : '';

        wmHtml = `
        <div style="
            text-align:center; 
            margin-top:30px; 
            margin-bottom: 100px; /* ADDED: Extra space at the bottom */
            padding:15px; 
            grid-column: 1 / -1; 
            display:flex; 
            flex-direction:column; 
            align-items:center; 
            justify-content:center;
            width: 100%;
            ${hoverStyle}" 
             onclick="openWanderingMonsterPicker()" 
             title="${isQuestEditMode ? 'Click to select a different monster' : ''}">
            <h4 style="margin:0 0 10px 0; color:#555; text-transform:uppercase; font-size:12px; letter-spacing:1px;">
                Wandering Monster
            </h4>
            <div style="display:flex; flex-direction:column; align-items:center; gap:5px;">
                <img src="${wm.imageUrl}" style="width:60px; height:60px; object-fit:contain; border:1px solid #ddd; background:white; padding:4px; border-radius:4px;">
                <strong style="font-size:18px;">${wm.name}</strong>
                <span style="font-size:11px; color:#888;">${hintText}</span>
            </div>
        </div>`;
    }

    // Update container style to ensure it expands
    const notesDiv = document.getElementById('questNotes');
    notesDiv.style.paddingBottom = "50px"; 
    notesDiv.innerHTML = roomHtml + wmHtml;
}

        // Helper to get footprint (used in drawBoard)
    function getFootprintSafe(item) {
            return getItemFootprint(item);
        }
		
	function capCorridors() {
    // 1. Identify spots that need capping
    const caps = [];
    
    for (let y = 0; y < GRID_HEIGHT; y++) {
        for (let x = 0; x < GRID_WIDTH; x++) {
            const current = grid[y][x];
            
            // We only care about ACTIVE corridors
            if (!current.active || current.type !== 'corridor') continue;

            const neighbors = [
                {x: x, y: y-1, face: 0}, // North
                {x: x+1, y: y, face: 1}, // East
                {x: x, y: y+1, face: 2}, // South
                {x: x-1, y: y, face: 3}  // West
            ];

            neighbors.forEach(n => {
                // Check bounds
                if (n.x >= 0 && n.x < GRID_WIDTH && n.y >= 0 && n.y < GRID_HEIGHT) {
                    const neighborCell = grid[n.y][n.x];
                    
                    // IF neighbor is a CORRIDOR but is INACTIVE
                    // Place a wall there to seal it off
                    if (neighborCell.type === 'corridor' && !neighborCell.active) {
                        
                        // Check if we already placed a wall there to avoid duplicates
                        const exists = manualWalls.some(w => w.x === n.x && w.y === n.y) || 
                                       caps.some(c => c.x === n.x && c.y === n.y);
                                       
                        if (!exists) {
                            // Find Wall1x1 data
                            const wallType = wallTypes.find(w => w.name === 'Wall1x1');
                            if (wallType) {
                                caps.push({
                                    wallData: wallType,
                                    x: n.x,
                                    y: n.y,
                                    facing: n.face, // Face towards the connection
                                    type_id: 'wall'
                                });
                            }
                        }
                    }
                }
            });
        }
    }

    // 2. Add to manualWalls array
    caps.forEach(c => manualWalls.push(c));
}

function drawBoard(targetCtx = null, overrideData = null) {
    const c = targetCtx || ctx;
    if (!c) return;

    // 1. Setup Data Sources
    const _grid = overrideData ? overrideData.grid : grid;
    const _activeRooms = (overrideData ? overrideData.activeRooms : activeRooms) || [];
    const _doors = (overrideData ? overrideData.doors : doors) || [];
    const _manualWalls = (overrideData ? overrideData.manualWalls : manualWalls) || [];
    const _placedFurniture = (overrideData ? overrideData.placedFurniture : placedFurniture) || [];
    const _placedTraps = (overrideData ? overrideData.placedTraps : placedTraps) || [];
    const _placedMonsters = (overrideData ? overrideData.placedMonsters : placedMonsters) || [];
    // New: Text Boxes
    const _placedTexts = (overrideData ? overrideData.placedTexts : placedTexts) || [];
    
    const _isEdit = overrideData ? false : isQuestEditMode;
    const _draggedItem = overrideData ? null : draggedItem;

    // 2. Clear Canvas & Draw Background
    c.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    const bgImg = document.getElementById('backgroundImage');
    
    if (bgImg && imageCache[bgImg.src]) {
        c.drawImage(imageCache[bgImg.src], 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    } else if (bgImg && bgImg.complete && bgImg.naturalWidth > 0) {
        try { c.drawImage(bgImg, 0, 0, CANVAS_WIDTH, CANVAS_HEIGHT); } catch (e) { }
    } else {
        c.fillStyle = "white";
        c.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    }

    // 3. Draw Floor Tiles
    if (typeof _grid !== 'undefined') {
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const cell = _grid[y][x];
                const px = x * SPACE_WIDTH;
                const py = y * SPACE_HEIGHT;

                if (!cell.active) {
                    // Inactive (Dark)
                    c.fillStyle = "rgba(0, 0, 0, 0.75)"; 
                    c.fillRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
                    
                    if (_isEdit) {
                        c.strokeStyle = "rgba(255,255,255,0.05)";
                        c.strokeRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
                    }
                } else {
                    // Active (Light)
                    c.fillStyle = (cell.type === 'room') ? ROOM_COLOR : CORRIDOR_COLOR;
                    c.fillRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
                    
                    c.strokeStyle = "rgba(0,0,0,0.15)";
                    c.lineWidth = 1;
                    c.strokeRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
                }
            }
        }
    }

    // 4. Draw Walls (Auto-generated on tile boundaries)
    c.save();
    c.strokeStyle = "black";
    c.lineWidth = 5;
    c.lineCap = "square";

    if (_grid) {
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const current = _grid[y][x];
                if (!current.active) continue;

                const px = x * SPACE_WIDTH;
                const py = y * SPACE_HEIGHT;

                const checks = [
                    { dir: 'N', nx: x, ny: y - 1, x1: px, y1: py, x2: px + SPACE_WIDTH, y2: py },
                    { dir: 'S', nx: x, ny: y + 1, x1: px, y1: py + SPACE_HEIGHT, x2: px + SPACE_WIDTH, y2: py + SPACE_HEIGHT },
                    { dir: 'W', nx: x - 1, ny: y, x1: px, y1: py, x2: px, y2: py + SPACE_HEIGHT },
                    { dir: 'E', nx: x + 1, ny: y, x1: px + SPACE_WIDTH, y1: py, x2: px + SPACE_WIDTH, y2: py + SPACE_HEIGHT }
                ];

                checks.forEach(edge => {
                    let needsWall = false;
                    // A. Map Edge
                    if (edge.nx < 0 || edge.nx >= GRID_WIDTH || edge.ny < 0 || edge.ny >= GRID_HEIGHT) {
                        needsWall = true;
                    } 
                    else {
                        const neighbor = _grid[edge.ny][edge.nx];
                        // B. Neighbor Inactive
                        if (!neighbor.active) needsWall = true;
                        // C. Different Room ID
                        else if (current.type === 'room' && neighbor.type === 'room' && current.roomInstanceId !== neighbor.roomInstanceId) needsWall = true;
                        // D. Room vs Corridor
                        else if (current.type !== neighbor.type) needsWall = true;
                    }

                    if (needsWall) {
                        // Offset logic for canvas edges
                        let sx1 = edge.x1, sy1 = edge.y1, sx2 = edge.x2, sy2 = edge.y2;
                        const offset = 2.5; 

                        if (edge.dir === 'N' && y === 0) { sy1 += offset; sy2 += offset; }
                        if (edge.dir === 'S' && y === GRID_HEIGHT - 1) { sy1 -= offset; sy2 -= offset; }
                        if (edge.dir === 'W' && x === 0) { sx1 += offset; sx2 += offset; }
                        if (edge.dir === 'E' && x === GRID_WIDTH - 1) { sx1 -= offset; sx2 -= offset; }

                        c.beginPath();
                        c.moveTo(sx1, sy1);
                        c.lineTo(sx2, sy2);
                        c.stroke();
                    }
                });
            }
        }
    }
    c.restore();

    // 5. Draw Text Labels (Bottom layer of assets, or top? Usually top is better, but below drag)
// 5. Draw Text Labels
    _placedTexts.forEach(t => {
        c.save();
        
        // Transform for Rotation
        const cx = (t.x + t.width/2) * SPACE_WIDTH;
        const cy = (t.y + t.height/2) * SPACE_HEIGHT;
        c.translate(cx, cy);
        c.rotate((t.rotation || 0) * Math.PI / 180);
        c.translate(-cx, -cy);

        const px = t.x * SPACE_WIDTH;
        const py = t.y * SPACE_HEIGHT;
        const pw = t.width * SPACE_WIDTH;
        const ph = t.height * SPACE_HEIGHT;

        // 1. Transparent Background (Only draw border if editing)
        if (_isEdit && editingTextItem === t) {
            c.strokeStyle = "#2196F3"; // Blue select border
            c.lineWidth = 2;
            c.setLineDash([5, 3]); // Dashed line
            c.strokeRect(px, py, pw, ph);
            c.setLineDash([]); 
        }

        // 2. Draw Text
        c.fillStyle = t.color || "black";
        c.font = `${t.fontSize || 16}px Arial`;
        c.textAlign = "center";
        c.textBaseline = "middle";
        
        const lines = t.text.split('\n');
        const lineHeight = (t.fontSize || 16) * 1.2;
        const totalTextH = lines.length * lineHeight;
        let startY = py + (ph - totalTextH)/2 + lineHeight/2;

        lines.forEach((line, i) => {
            c.fillText(line, px + pw/2, startY + (i * lineHeight));
        });

        // 3. Draw Thick Arrow (SHORTENED)
        // Logic: Start at the edge of the box, extend 25px out.
        if (t.arrow && t.arrow !== 'none') {
            c.fillStyle = "#000"; 
            c.strokeStyle = "#000";
            c.lineWidth = 4;
            c.lineCap = "round";
            c.beginPath();
            
            const arrowSize = 10; 
            const stickLen = 25; // Shorter stick length
            
            if (t.arrow === 'up') {
                // Start at Top Edge, Go Up
                c.moveTo(px + pw/2, py); 
                c.lineTo(px + pw/2, py - stickLen); 
                c.stroke();
                // Head
                c.beginPath();
                c.moveTo(px + pw/2, py - stickLen - arrowSize * 0.5); // Tip
                c.lineTo(px + pw/2 - arrowSize, py - stickLen + arrowSize * 0.5);
                c.lineTo(px + pw/2 + arrowSize, py - stickLen + arrowSize * 0.5);
                c.fill();
            } else if (t.arrow === 'down') {
                // Start at Bottom Edge, Go Down
                c.moveTo(px + pw/2, py + ph);
                c.lineTo(px + pw/2, py + ph + stickLen);
                c.stroke();
                c.beginPath();
                c.moveTo(px + pw/2, py + ph + stickLen + arrowSize * 0.5);
                c.lineTo(px + pw/2 - arrowSize, py + ph + stickLen - arrowSize * 0.5);
                c.lineTo(px + pw/2 + arrowSize, py + ph + stickLen - arrowSize * 0.5);
                c.fill();
            } else if (t.arrow === 'left') {
                // Start at Left Edge, Go Left
                c.moveTo(px, py + ph/2); 
                c.lineTo(px - stickLen, py + ph/2);
                c.stroke();
                c.beginPath();
                c.moveTo(px - stickLen - arrowSize * 0.5, py + ph/2);
                c.lineTo(px - stickLen + arrowSize * 0.5, py + ph/2 - arrowSize);
                c.lineTo(px - stickLen + arrowSize * 0.5, py + ph/2 + arrowSize);
                c.fill();
            } else if (t.arrow === 'right') {
                // Start at Right Edge, Go Right
                c.moveTo(px + pw, py + ph/2);
                c.lineTo(px + pw + stickLen, py + ph/2);
                c.stroke();
                c.beginPath();
                c.moveTo(px + pw + stickLen + arrowSize * 0.5, py + ph/2);
                c.lineTo(px + pw + stickLen - arrowSize * 0.5, py + ph/2 - arrowSize);
                c.lineTo(px + pw + stickLen - arrowSize * 0.5, py + ph/2 + arrowSize);
                c.fill();
            }
        }

        // 4. Editor Handles
        if (_isEdit && editingTextItem === t) {
            c.fillStyle = "#2196F3"; 
            const hSize = 10;
            // Corners
            c.fillRect(px - hSize/2, py - hSize/2, hSize, hSize); 
            c.fillRect(px + pw - hSize/2, py - hSize/2, hSize, hSize); 
            c.fillRect(px - hSize/2, py + ph - hSize/2, hSize, hSize); 
            c.fillRect(px + pw - hSize/2, py + ph - hSize/2, hSize, hSize); 
            // Rotation
            c.beginPath();
            c.arc(px + pw/2, py - 25, 6, 0, Math.PI*2);
            c.fill();
            c.beginPath();
            c.moveTo(px + pw/2, py);
            c.lineTo(px + pw/2, py - 25);
            c.stroke();
        }
        c.restore();
    });
    // 6. Draw Standard Assets
    const drawItem = (item, imgUrl, w, h, isRot) => {
        if (!imgUrl || !imageCache[imgUrl]) return;
        c.save();
        const centerX = (item.x + (isRot?h:w)/2) * SPACE_WIDTH;
        const centerY = (item.y + (isRot?w:h)/2) * SPACE_HEIGHT;
        c.translate(centerX, centerY);
        c.rotate((item.facing * 90) * Math.PI / 180);
        
        if (_isEdit && _draggedItem === item) { 
            c.shadowBlur = 15; c.shadowColor = "cyan"; 
        }
        
        c.drawImage(imageCache[imgUrl], -(w*SPACE_WIDTH)/2, -(h*SPACE_HEIGHT)/2, w*SPACE_WIDTH, h*SPACE_HEIGHT);
        c.restore();
    };

    _manualWalls.forEach(w => w.wallData && drawItem(w, w.wallData.imageUrl, w.wallData.size.width, w.wallData.size.height, w.facing%2!==0));
    _placedFurniture.forEach(f => f.furniture && drawItem(f, f.furniture.imageUrl, f.furniture.size.width, f.furniture.size.height, f.facing%2!==0));
    _placedTraps.forEach(t => {
        const type = trapTypes.find(x => x.name === t.type);
        if(type) drawItem(t, type.imageUrl, 1, 1, false);
    });
    _placedMonsters.forEach(m => {
        if(m.type) {
             const w = (m.type.size.width === 1 && m.type.size.height === 1) ? 1 : m.type.size.width;
             const h = (m.type.size.width === 1 && m.type.size.height === 1) ? 1 : m.type.size.height;
             drawItem(m, m.type.imageUrl, w, h, m.facing%2!==0);
        }
    });
    _doors.forEach(d => {
        const isSecret = d.secret;
        const img = isSecret ? DOOR_IMAGES['SecretDoor'] : DOOR_IMAGES['Door1x1'];
        const w = isSecret ? 1 : (DOOR_IMAGE_WIDTH/SPACE_WIDTH);
        const h = isSecret ? 2 : (DOOR_IMAGE_HEIGHT/SPACE_HEIGHT);
        if(imageCache[img]) {
            c.save();
            c.translate((d.x + 0.5) * SPACE_WIDTH, (d.y + 0.5) * SPACE_HEIGHT);
            c.rotate((d.facing * 90) * Math.PI / 180);
            if (_isEdit && _draggedItem === d) { c.shadowBlur = 15; c.shadowColor = "cyan"; }
            c.drawImage(imageCache[img], -(w*SPACE_WIDTH)/2, -(h*SPACE_HEIGHT)/2, w*SPACE_WIDTH, h*SPACE_HEIGHT);
            c.restore();
        }
    });

    // 7. Draw Room Labels (Red Letters)
    const showLabels = overrideData ? true : (document.getElementById('showRoomNumbers') && document.getElementById('showRoomNumbers').checked);
    if (showLabels && _activeRooms) {
        _activeRooms.forEach(r => {
            if (r.labelX !== undefined && r.letter) {
                c.save();
                c.fillStyle = "red";
                c.font = "bold 26px Arial";
                c.textAlign = "center";
                c.textBaseline = "middle";
                c.shadowColor = "white";
                c.shadowBlur = 10;
                c.fillText(r.letter, (r.labelX + 0.5) * SPACE_WIDTH, (r.labelY + 0.5) * SPACE_HEIGHT);
                c.restore();
            }
        });
    }

    // 8. Draw Dragged Label (Visual Feedback)
    if (_isEdit && _draggedItem) {
        if (_draggedItem.type_id === 'label') {
            c.save();
            c.fillStyle = "#b22222"; 
            c.font = "bold 28px Arial";
            c.textAlign = "center";
            c.textBaseline = "middle";
            c.shadowColor = "white";
            c.shadowBlur = 5;
            const dx = (_draggedItem.x + 0.5) * SPACE_WIDTH;
            const dy = (_draggedItem.y + 0.5) * SPACE_HEIGHT;
            c.fillText(_draggedItem.letter, dx, dy);
            c.restore();
        }
    }

    // 9. Editor Cursor
    if (_isEdit && !_draggedItem && !overrideData) {
        c.strokeStyle = "rgba(0, 255, 255, 0.5)";
        c.lineWidth = 3;
        c.strokeRect(mousePos.x * SPACE_WIDTH, mousePos.y * SPACE_HEIGHT, SPACE_WIDTH, SPACE_HEIGHT);
    }
}

        // --- PREVIEW RENDERER (Full Sheet) ---
        let previewZoom = 0.4; // Default scale to fit
        let previewTranslation = { x: 0, y: 0 };

        function zoomPreview(delta) {
            previewZoom = Math.max(0.1, Math.min(2.0, previewZoom + delta));
            updatePreviewTransform();
        }

        function updatePreviewTransform() {
            const el = document.getElementById('previewContainer');
            if (el) {
                el.style.transform = "scale(" + previewZoom + ")";
            }
        }

        function renderFullPreview(data, containerId = 'previewContainer', metadata = null) {
            // 1. Generate High-Res Map Image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = CANVAS_WIDTH;
            tempCanvas.height = CANVAS_HEIGHT;
            const tCtx = tempCanvas.getContext('2d');

            // Draw Board Components (Includes BG now)
            drawBoard(tCtx, data);

            const mapDataUrl = tempCanvas.toDataURL();

            // 2. Build HTML Content
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = ''; // Clear previous

            // Container Styling
            container.style.width = CANVAS_WIDTH + "px";
            container.style.height = "auto";
            container.style.minHeight = CANVAS_HEIGHT + "px";
            container.style.padding = "20px";
            container.style.boxSizing = "border-box";
            container.style.color = "black";
            container.style.fontFamily = "Arial, sans-serif";

            // Title Header (Gray Box)
            const header = document.createElement('div');
            header.style.marginBottom = "20px";
            header.style.background = "#ddd";
            header.style.padding = "15px";
            header.style.borderRadius = "5px";

            const qTitle = data.questName || "Untitled Quest";
            const qFlavor = data.questDesc || (data.questDefinition ? data.questDefinition.flavor : "") || "No description.";
            const qGoal = (data.questDefinition && data.questDefinition.goal) ? data.questDefinition.goal : "Explore the dungeon.";
            const qRewards = (data.questDefinition && data.questDefinition.rewards) ? data.questDefinition.rewards : "None.";

            // Metadata visual logic
            let metaHtml = "";
            if (metadata) {
                const parts = [];
                if (metadata.author) parts.push(`<strong>Author:</strong> ${metadata.author}`);
                if (metadata.date) parts.push(`${metadata.date}`);
                if (metadata.rating !== undefined) {
                    let stars = '';
                    for (let i = 0; i < 5; i++) stars += (i < Math.round(metadata.rating)) ? '‚òÖ' : '‚òÜ';
                    parts.push(`<span style="color:#d4af37; font-size:1.2em;">${stars}</span>`);
                }
                if (parts.length > 0) metaHtml = `<div style="font-size:0.9em; color:#555; margin-bottom:8px;">${parts.join(' &nbsp;‚Ä¢&nbsp; ')}</div>`;
            }

            header.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:start;">
                    <div style="width:100%;">
                        <h2 style="margin:0 0 5px 0;">${qTitle}</h2>
                        ${metaHtml}
                        <p style="margin:0 0 10px 0;"><em>${qFlavor}</em></p>
                        <p style="margin:5px 0;"><strong>Goal:</strong> ${qGoal}</p>
                        <p style="margin:5px 0;"><strong>Rewards:</strong> ${qRewards}</p>
                    </div>
                     ${containerId === 'previewContainer' ?
                    '<button onclick="downloadSelectedQuest()" style="background:#4CAF50; color:white; border:none; padding:10px 20px; cursor:pointer; font-size:14px; border-radius:4px; font-weight:bold; white-space:nowrap; margin-left:15px;">Import Quest</button>'
                    : ''}
                </div>`;
            // container.appendChild(header); // Moved to after map to match visual order request

            // Map Image
            const img = document.createElement('img');
            img.src = mapDataUrl;
            img.style.width = "100%";
            img.style.border = "4px solid #333";
            img.style.display = "block";
            img.style.marginBottom = "25px";
            container.appendChild(img);
            container.appendChild(header); // Header appended AFTER map (so map is on top)

            // Room Notes Grid
            const notes = document.createElement('div');
            notes.style.display = "grid";
            notes.style.gridTemplateColumns = "1fr 1fr"; // Two columns
            notes.style.gap = "20px";

            if (data.activeRooms) {
                // Sort rooms alpha-numerically
                data.activeRooms.sort((a, b) => (a.letter || '').localeCompare(b.letter || '')).forEach(r => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'room-section'; // Uses the styling we added earlier
                    noteItem.style.breakInside = "avoid";

                    // Match with Definition
                    let def = null;
                    if (data.questDefinition && data.questDefinition.rooms) {
                        def = data.questDefinition.rooms.find(x => x.letter === r.letter);
                    }

                    const rName = (def && def.name) ? def.name : (r.name || `Area ${r.roomNumber}`);
                    const rFlavor = (def && def.flavor) ? def.flavor : (r.flavor || "");

                    let html = `<h4 style="margin-top:0; color:#b22222;">Room ${r.letter} - ${rName}</h4>`;
                    if (rFlavor) html += `<p style="font-size:0.95em; margin-bottom:10px;"><em>${rFlavor}</em></p>`;

                    // --- Content Counting Logic ---
                    const inRoom = (obj) => {
                        // Simple check: is center of object inside the room rect?
                        // Or simple x,y check. 
                        // room x,y is top-left, width/height is size.
                        const ox = obj.x, oy = obj.y;
                        // Add 0.5 for center check? Or just Top-Left check.
                        // Items are placed on integer coords. Room is at integer coords.
                        return ox >= r.x && ox < r.x + r.width && oy >= r.y && oy < r.y + r.height;
                    };

                    const monsters = (data.placedMonsters || []).filter(inRoom);
                    const furniture = (data.placedFurniture || []).filter(inRoom);
                    const traps = (data.placedTraps || []).filter(inRoom);

                    if (monsters.length > 0) {
                        const counts = monsters.reduce((acc, m) => {
                            const name = m.type.name || m.type;
                            acc[name] = (acc[name] || 0) + 1;
                            return acc;
                        }, {});

                        // Attempt to find icons
                        const monStr = Object.entries(counts).map(([name, count]) => {
                            // Try to find helper image
                            let iconImg = "";
                            const typeObj = monsterTypes.find(t => t.name === name);
                            if (typeObj && typeObj.imageUrl) {
                                iconImg = `<img src="${typeObj.imageUrl}" style="width:24px; vertical-align:middle; margin-right:4px;">`;
                            }
                            return `<div style="display:inline-block; margin-right:15px; margin-bottom:5px;">${iconImg}<strong>${count}</strong> ${name}</div>`;
                        }).join(' ');
                        html += `<div style="margin-top:5px;"><strong>Monsters:</strong><br>${monStr}</div>`;
                    }

                    if (furniture.length > 0) {
                        const counts = furniture.reduce((acc, f) => {
                            const name = f.furniture.name || f.furniture;
                            acc[name] = (acc[name] || 0) + 1;
                            return acc;
                        }, {});
                        const furnStr = Object.entries(counts).map(([name, count]) => `${count} ${name}`).join(', ');
                        html += `<div style="margin-top:5px;"><strong>Furniture:</strong> ${furnStr}</div>`;
                    }

                    if (traps.length > 0) {
                        const counts = traps.reduce((acc, t) => {
                            const name = t.type.name || t.type;
                            acc[name] = (acc[name] || 0) + 1;
                            return acc;
                        }, {});
                        const trapStr = Object.entries(counts).map(([name, count]) => `${count} ${name}`).join(', ');
                        html += `<div style="margin-top:5px;"><strong>Traps:</strong> ${trapStr}</div>`;
                    }

                    noteItem.innerHTML = html;
                    notes.appendChild(noteItem);
                });
            }
            container.appendChild(notes);

            // Reset Zoom
            previewZoom = 0.45; // Start zoomed out
            updatePreviewTransform();

            // Init Drag (Pan) - only for main preview? OR make generic
            // initPreviewPan hardcodes ID. We should update it if we want panning in both.
            // For now, let's leave panning broken in local vault or update it later.
        }

        function initPreviewPan() {
            const el = document.getElementById('previewContainer');
            const parent = el.parentElement; // The overflow hidden container
            let isDown = false;
            let startX, startY, scrollLeft, scrollTop;

            parent.addEventListener('mousedown', (e) => {
                isDown = true;
                parent.style.cursor = 'grabbing';
                startX = e.pageX - parent.offsetLeft;
                startY = e.pageY - parent.offsetTop;
                scrollLeft = parent.scrollLeft;
                scrollTop = parent.scrollTop;
            });

            parent.addEventListener('mouseleave', () => { isDown = false; parent.style.cursor = 'grab'; });
            parent.addEventListener('mouseup', () => { isDown = false; parent.style.cursor = 'grab'; });

            parent.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - parent.offsetLeft;
                const y = e.pageY - parent.offsetTop;
                const walkX = (x - startX) * 1.5;
                const walkY = (y - startY) * 1.5;
                parent.scrollLeft = scrollLeft - walkX;
                parent.scrollTop = scrollTop - walkY;
            });
        }


        // --- NEW SOCIAL & UI LOGIC ---

        // 1. UI TOGGLES
        function toggleLeftPanel() {
            const p = document.getElementById('tileSidePanel');
            const right = document.getElementById('assetLibrary');
            if (p.style.display === 'block') {
                p.style.display = 'none';
            } else {
                p.style.display = 'block';
                if (right) right.style.display = 'none';
                // Close other modals if open
            }
        }

        function toggleRightPanel() {
            const p = document.getElementById('assetLibrary');
            const left = document.getElementById('tileSidePanel');
            if (p.style.display === 'block') {
                p.style.display = 'none';
            } else {
                p.style.display = 'block';
                if (left) left.style.display = 'none';
            }
        }

        // Global Cache for loaded community quests
        let communityCache = [];
        let selectedQuestData = null;

function toggleCommunity() {
    // 1. Security Check: Are we logged in?
    if (!currentUser) {
        showCustomAlert("Please login to access the Community Vault.", "Login Required");
        toggleAuthModal(); // Open the Login/Register window
        return; // Stop here
    }

    const m = document.getElementById('communityModal');
    const o = document.getElementById('overlay');
    
    // Check current state (using Flex for this specific modal)
    const isVisible = m.style.display === 'flex';

    if (isVisible) {
        m.style.display = 'none';
        o.style.display = 'none';
    } else {
        m.style.display = 'flex';
        o.style.display = 'block';

        // Load content now that we know we are logged in
        loadCommunityQuests();
        
        // Reset Preview UI
        const pc = document.getElementById('previewContainer');
        if (pc) pc.innerHTML = '<div style="color:#666; text-align:center; padding-top:50px;">Select a quest to preview</div>';
        
        // Reset Rating UI
        const rateEl = document.getElementById('userRatingInput');
        if (rateEl) rateEl.style.display = 'none'; // Will show when quest selected
        
        selectedQuestData = null;
    }
}

        function loadCommunityQuests() {
            const list = document.getElementById('communityList');
            list.innerHTML = '<p style="text-align:center;">Loading quests...</p>';

            // Fetch last 50 for better search experience
            database.ref('quests').limitToLast(50).once('value').then((snapshot) => {
                list.innerHTML = '';
                communityCache = [];

                if (!snapshot.exists()) {
                    list.innerHTML = '<p style="padding:10px; text-align:center;">No shared quests found.</p>';
                    return;
                }

                snapshot.forEach(child => {
                    communityCache.push({ id: child.key, ...child.val() });
                });

                // Initial Render (Newest First)
                communityCache.reverse();
                renderCommunityList(communityCache);
            });
        }

        function renderCommunityList(quests) {
            const list = document.getElementById('communityList');
            list.innerHTML = '';

            quests.forEach(q => {
                const tagsHtml = q.tags ? '<div style="font-size:10px; color:#888; margin-top:2px;">' + q.tags + '</div>' : '';
                const item = document.createElement('div');
                item.className = 'vault-item';
                item.style.cssText = 'cursor:pointer; position:relative; padding-right:30px;';
                item.onclick = () => selectCommunityQuest(q.id);

                // Check if current user owns this quest
                const isOwner = currentUser && q.authorId === currentUser.uid;
                const deleteBtn = isOwner ?
                    '<span onclick="event.stopPropagation(); deleteQuest(\'' + q.id + '\')" ' +
                    'style="position:absolute; right:5px; top:50%; transform:translateY(-50%); ' +
                    'color:red; font-weight:bold; font-size:18px; cursor:pointer; padding:5px;" ' +
                    'title="Delete Quest">&times;</span>' : '';

                item.innerHTML = '<div style="width:100%;">' +
                    '<strong style="color:#673ab7;">' + q.name + '</strong>' +
                    '<div style="font-size:11px; color:#555;">by ' + (q.authorName || 'Unknown') + '</div>' +
                    '<div style="font-size:10px; color:#fbc02d;">‚òÖ ' + (q.rating || '0.0') + ' (' + (q.ratingCount || 0) + ')</div>' +
                    tagsHtml +
                    '</div>' + deleteBtn;

                list.appendChild(item);
            });
        }

        function filterCommunityQuests() {
            const term = document.getElementById('communitySearch').value.toLowerCase();
            const filtered = communityCache.filter(q =>
                q.name.toLowerCase().includes(term) ||
                (q.authorName && q.authorName.toLowerCase().includes(term)) ||
                (q.tags && q.tags.toLowerCase().includes(term))
            );
            renderCommunityList(filtered);
        }

        function sortCommunityQuests() {
            const mode = document.getElementById('communitySort').value;
            let sorted = [...communityCache];

            if (mode === 'myquests') {
                // Filter to show only user's quests
                if (!currentUser) {
                    alert('Please login to view your quests!');
                    document.getElementById('communitySort').value = 'newest';
                    return;
                }
                sorted = sorted.filter(q => q.authorId === currentUser.uid);
                sorted.sort((a, b) => b.timestamp - a.timestamp);
            } else if (mode === 'newest') {
                sorted.sort((a, b) => b.timestamp - a.timestamp);
            } else if (mode === 'rating') {
                sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0));
            } else if (mode === 'comments') {
                sorted.sort((a, b) => (b.commentCount || 0) - (a.commentCount || 0));
            }

            renderCommunityList(sorted);
        }

        function deleteQuest(questId) {
            if (!currentUser) {
                showCustomAlert('You must be logged in to delete quests!', 'Login Required');
                return;
            }

            // Verify ownership
            database.ref('quests/' + questId).once('value').then(snapshot => {
                const quest = snapshot.val();

                if (!quest) {
                    showCustomAlert('Quest not found!', 'Error');
                    return;
                }

                if (quest.authorId !== currentUser.uid) {
                    showCustomAlert('You can only delete your own quests!', 'Permission Denied');
                    return;
                }

                // Show custom confirm modal
                showConfirmModal(
                    'Are you sure you want to delete "' + quest.name + '"?',
                    'This will also remove all comments and ratings.',
                    function () {
                        // Delete quest and all associated data
                        Promise.all([
                            database.ref('quests/' + questId).remove(),
                            database.ref('comments/' + questId).remove(),
                            database.ref('ratings/' + questId).remove()
                        ]).then(() => {
                            showCustomAlert('Quest deleted successfully!', 'Success');
                            loadCommunityQuests(); // Reload the list
                        }).catch(error => {
                            showCustomAlert('Error deleting quest: ' + error.message, 'Error');
                        });
                    }
                );
            });
        }

        function selectCommunityQuest(qid) {
            const q = communityCache.find(x => x.id === qid);
            if (!q) return;

            selectedQuestData = q;

            // Draw Preview (Full HTML Version) with Metadata
            if (q.data) {
                renderFullPreview(q.data, 'previewContainer', {
                    author: q.authorName || 'Anonymous',
                    rating: q.rating || 0,
                    date: new Date(q.timestamp).toLocaleDateString()
                });
            }

            // Load comments and ratings for this quest
            loadQuestRatings(qid);
            loadQuestComments(qid);

            // Show rating input if user is logged in
            const userRatingInput = document.getElementById('userRatingInput');
            if (userRatingInput) {
                userRatingInput.style.display = currentUser ? 'block' : 'none';
            }
        }

        // --- COMMENTS & RATINGS SYSTEM ---
        let currentQuestId = null;
        let currentReplyTo = null;

        function loadQuestRatings(questId) {
            currentQuestId = questId;

            // Fetch ratings from Firebase
            database.ref('ratings/' + questId).once('value').then(snapshot => {
                const ratings = snapshot.val() || {};
                const ratingValues = Object.values(ratings).map(r => r.rating);

                const avgDisplay = document.getElementById('averageRating');
                const countDisplay = document.getElementById('ratingCount');

                if (ratingValues.length > 0) {
                    const avg = ratingValues.reduce((a, b) => a + b, 0) / ratingValues.length;
                    avgDisplay.innerHTML = getStars(avg, true);
                    countDisplay.textContent = `${avg.toFixed(1)} / 5 (${ratingValues.length} ratings)`;
                } else {
                    avgDisplay.innerHTML = '‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ';
                    countDisplay.textContent = 'No ratings yet';
                }

                // Highlight user's rating if they've rated
                if (currentUser && ratings[currentUser.uid]) {
                    highlightUserRating(ratings[currentUser.uid].rating);
                }
            });
        }

        function getStars(rating, filled = false) {
            const fullStars = Math.floor(rating);
            const halfStar = (rating % 1) >= 0.5;
            const emptyStars = 5 - fullStars - (halfStar ? 1 : 0);

            return '‚òÖ'.repeat(fullStars) + (halfStar ? '‚Ø®' : '') + '‚òÜ'.repeat(emptyStars);
        }

        function rateQuest(stars) {
            if (!currentUser) {
                alert('Please login to rate quests!');
                toggleAuthModal();
                return;
            }
            if (!currentQuestId) return;

            // Save rating to Firebase
            database.ref('ratings/' + currentQuestId + '/' + currentUser.uid).set({
                rating: stars,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            }).then(() => {
                loadQuestRatings(currentQuestId);
                highlightUserRating(stars);
            });
        }

        function highlightUserRating(stars) {
            const starInputs = document.querySelectorAll('#starRatingInput span');
            starInputs.forEach((span, idx) => {
                span.innerHTML = idx < stars ? '‚òÖ' : '‚òÜ';
                span.style.color = idx < stars ? '#fbc02d' : '#ddd';
            });
        }

        function loadQuestComments(questId) {
            currentQuestId = questId;

            database.ref('comments/' + questId).orderByChild('timestamp').once('value').then(snapshot => {
                const commentsList = document.getElementById('commentsList');
                commentsList.innerHTML = '';

                if (!snapshot.exists()) {
                    commentsList.innerHTML = '<div style="text-align:center; color:#999; padding:20px;">No comments yet. Be the first!</div>';
                    return;
                }

                const comments = [];
                snapshot.forEach(child => {
                    comments.push({ id: child.key, ...child.val() });
                });

                // Sort by timestamp (newest first) and separate top-level from replies
                comments.reverse();
                const topLevel = comments.filter(c => !c.parentCommentId);

                topLevel.forEach(comment => {
                    const replies = comments.filter(c => c.parentCommentId === comment.id);
                    commentsList.appendChild(renderComment(comment, replies));
                });

                // Show "Add Comment" button
                document.getElementById('addCommentBtn').style.display = currentUser ? 'block' : 'none';
            });
        }

        function renderComment(comment, replies = []) {
            const div = document.createElement('div');
            div.style.cssText = 'border-bottom:1px solid #eee; padding:10px 0;';

            // Get vote counts
            const upvotes = comment.upvotes || 0;
            const downvotes = comment.downvotes || 0;
            const score = upvotes - downvotes;

            div.innerHTML = `
                <div style="display:flex; align-items:flex-start; gap:8px;">
                    <div style="text-align:center; min-width:30px;">
                        <div onclick="voteComment('${comment.id}', 1)" style="cursor:pointer; font-size:16px; color:#666;" title="Thumbs Up">üëç</div>
                        <div style="font-size:11px; font-weight:bold; color:${score >= 0 ? '#4CAF50' : '#f44336'};">${score}</div>
                        <div onclick="voteComment('${comment.id}', -1)" style="cursor:pointer; font-size:16px; color:#666;" title="Thumbs Down">üëé</div>
                    </div>
                    <div style="flex:1;">
                        <div style="font-size:12px; color:#666; margin-bottom:4px;">
                            <strong>${comment.userName || 'Anonymous'}</strong> ¬∑ ${timeAgo(comment.timestamp)}
                        </div>
                        <div style="font-size:13px; color:#333; margin-bottom:6px;">${escapeHtml(comment.text)}</div>
                        <button onclick="replyToComment('${comment.id}')" style="font-size:11px; color:#673ab7; background:none; border:none; cursor:pointer; padding:0;">Reply</button>
                    </div>
                </div>
            `;

            // Add replies (indented)
            if (replies.length > 0) {
                const repliesContainer = document.createElement('div');
                repliesContainer.style.cssText = 'margin-left:40px; margin-top:10px;';
                replies.forEach(reply => {
                    repliesContainer.appendChild(renderComment(reply, []));
                });
                div.appendChild(repliesContainer);
            }

            return div;
        }

        function timeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            if (seconds < 60) return 'just now';
            if (seconds < 3600) return Math.floor(seconds / 60) + 'm ago';
            if (seconds < 86400) return Math.floor(seconds / 3600) + 'h ago';
            return Math.floor(seconds / 86400) + 'd ago';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showCommentInput() {
            if (!currentUser) {
                alert('Please login to comment!');
                toggleAuthModal();
                return;
            }
            document.getElementById('commentInputSection').style.display = 'block';
            document.getElementById('addCommentBtn').style.display = 'none';
            document.getElementById('newCommentText').focus();
        }

        function cancelComment() {
            document.getElementById('commentInputSection').style.display = 'none';
            document.getElementById('addCommentBtn').style.display = 'block';
            document.getElementById('newCommentText').value = '';
            currentReplyTo = null;
        }

        function replyToComment(commentId) {
            if (!currentUser) {
                alert('Please login to reply!');
                toggleAuthModal();
                return;
            }
            currentReplyTo = commentId;
            showCommentInput();
        }

        function submitComment() {
            if (!currentUser || !currentQuestId) return;

            const text = document.getElementById('newCommentText').value.trim();
            if (!text) return;

            const commentData = {
                userId: currentUser.uid,
                userName: currentUser.displayName || currentUser.email,
                text: text,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                upvotes: 0,
                downvotes: 0
            };

            if (currentReplyTo) {
                commentData.parentCommentId = currentReplyTo;
            }

            database.ref('comments/' + currentQuestId).push(commentData).then(() => {
                loadQuestComments(currentQuestId);
                cancelComment();

                // Update comment count on quest
                database.ref('quests/' + currentQuestId + '/commentCount').transaction(count => (count || 0) + 1);
            });
        }

        function voteComment(commentId, vote) {
            if (!currentUser) {
                alert('Please login to vote!');
                toggleAuthModal();
                return;
            }

            const userVoteRef = database.ref('userVotes/' + commentId + '/' + currentUser.uid);
            const commentRef = database.ref('comments/' + currentQuestId + '/' + commentId);

            userVoteRef.once('value').then(snapshot => {
                const existingVote = snapshot.val();

                if (existingVote && existingVote.vote === vote) {
                    // Remove vote if clicking same button
                    userVoteRef.remove();
                    commentRef.child(vote === 1 ? 'upvotes' : 'downvotes').transaction(count => Math.max(0, (count || 0) - 1));
                } else if (existingVote) {
                    // Change vote
                    const oldField = existingVote.vote === 1 ? 'upvotes' : 'downvotes';
                    const newField = vote === 1 ? 'upvotes' : 'downvotes';
                    commentRef.child(oldField).transaction(count => Math.max(0, (count || 0) - 1));
                    commentRef.child(newField).transaction(count => (count || 0) + 1);
                    userVoteRef.set({ vote });
                } else {
                    // New vote
                    const field = vote === 1 ? 'upvotes' : 'downvotes';
                    commentRef.child(field).transaction(count => (count || 0) + 1);
                    userVoteRef.set({ vote });
                }

                loadQuestComments(currentQuestId);
            });
        }

        function resetPreviewZoom() {
            previewZoom = 0.45;
            updatePreviewTransform();
        }

        function renderPreview(data) {
            const pCanvas = document.getElementById('previewCanvas');
            const ctx = pCanvas.getContext('2d');
            ctx.clearRect(0, 0, pCanvas.width, pCanvas.height);

            // Simple Preview Renderer (Partial implementation of drawBoard)
            // 1. Draw Grid/Floors
            if (data.grid) {
                for (let y = 0; y < GRID_HEIGHT; y++) {
                    for (let x = 0; x < GRID_WIDTH; x++) {
                        const cell = data.grid[y][x];
                        if (!cell.active) continue;

                        const px = x * SPACE_WIDTH, py = y * SPACE_HEIGHT;
                        ctx.fillStyle = (cell.type === 'corridor') ? CORRIDOR_COLOR : ROOM_COLOR;
                        ctx.fillRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);

                        // Walls logic is complex, skipping for lightweight preview or simplifying:
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(px, py, SPACE_WIDTH, SPACE_HEIGHT);
                    }
                }
            }

            // 2. Draw Icons (furniture/monsters) - simplified
            // Helper to draw image if loaded
            const drawIcon = (arr, getImgKey) => {
                if (!arr) return;
                arr.forEach(item => {
                    // Need mapping from item type to image key in imageCache
                    // This depends on the stored data structure.
                    // The getQuestData uses placedFurniture.map(f => ({... f.furniture}))
                    // f.furniture usually has .imageUrl

                    let imgUrl = null;
                    if (item.furniture) imgUrl = item.furniture.imageUrl;
                    else if (item.type && item.type.imageUrl) imgUrl = item.type.imageUrl; // Monsters
                    else if (item.wallData) imgUrl = item.wallData.imageUrl; // Walls

                    if (imgUrl && imageCache[imgUrl]) {
                        ctx.drawImage(imageCache[imgUrl], item.x * SPACE_WIDTH, item.y * SPACE_HEIGHT, SPACE_WIDTH, SPACE_HEIGHT);
                    }
                });
            };

            drawIcon(data.placedFurniture);
            drawIcon(data.placedMonsters);
            drawIcon(data.manualWalls);
            drawIcon(data.doors); // Doors might need separate logic for rotation, but this is a rough preview
        }

        function downloadSelectedQuest() {
            if (!selectedQuestData || !selectedQuestData.data) return;
            loadQuestData(selectedQuestData.data);
            toggleCommunity();
            // alert("Quest Loaded!");
        }

        // 4. SHARE LOGIC
function toggleShareModal() {
    const m = document.getElementById('shareModal');
    const o = document.getElementById('overlay');
    
    // Check if the modal is currently visible
    const isVisible = m.style.display === 'block';

    if (isVisible) {
        // If it's open, just close it
        m.style.display = 'none';
        o.style.display = 'none';
    } else {
        // If opening, CHECK LOGIN STATUS FIRST
        if (!currentUser) {
            showCustomAlert("Please login to share your quest with the community.", "Login Required");
            toggleAuthModal(); // Open the login screen instead
            return;
        }

        // If logged in, show the Share Modal
        m.style.display = 'block';
        o.style.display = 'block';

        // Pre-fill fields with current quest data
        if (currentQuest) {
            document.getElementById('shareName').value = currentQuest.name || "My Custom Quest";
            document.getElementById('shareDesc').value = currentQuest.flavor || "";
            document.getElementById('shareTags').value = currentQuest.tags || "";
        }
    }
}

function confirmShare() {
    // 1. Final Safety Check
    if (!currentUser) {
        showCustomAlert("Session expired. Please login again.", "Error");
        toggleShareModal(); // Close share modal
        toggleAuthModal();  // Open login
        return;
    }

    const name = document.getElementById('shareName').value;
    const desc = document.getElementById('shareDesc').value;
    const tags = document.getElementById('shareTags').value;

    if (!name) return showCustomAlert("Please enter a Quest Name.");

    const questData = getQuestData();

    // 2. Save to Firebase
    const newQuestRef = database.ref('quests').push();
    newQuestRef.set({
        name: name,
        description: desc,
        tags: tags || "Community",
        authorId: currentUser.uid, // Safe to access now
        authorName: currentUser.displayName || 'Anonymous',
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        rating: 0,
        ratingCount: 0,
        data: questData
    }).then(() => {
        showCustomAlert("Quest Published Successfully!", "Success");
        
        // Close modal manually
        document.getElementById('shareModal').style.display = 'none';
        document.getElementById('overlay').style.display = 'none';
        
        // Update user stats
        database.ref('users/' + currentUser.uid + '/questsShared').transaction(current => (current || 0) + 1);
    }).catch(e => {
        showCustomAlert("Error sharing: " + e.message);
    });
}

function toggleShareModal() {
    // 1. Security Check: Are we logged in?
    if (!currentUser) {
        showCustomAlert("You must be logged in to share a quest.", "Login Required");
        toggleAuthModal(); // Open the Login/Register window
        return; // Stop here, do not open the Share window
    }

    const m = document.getElementById('shareModal');
    const o = document.getElementById('overlay');
    
    const isVisible = m.style.display === 'block';

    if (isVisible) {
        m.style.display = 'none';
        o.style.display = 'none';
    } else {
        // Only open if logged in (double check handled above)
        m.style.display = 'block';
        o.style.display = 'block';

        // Pre-fill inputs
        if (currentQuest) {
            document.getElementById('shareName').value = currentQuest.name || "My Custom Quest";
            document.getElementById('shareDesc').value = currentQuest.flavor || "";
            document.getElementById('shareTags').value = currentQuest.tags || "";
        }
    }
}

function getQuestData() {
    // Helper to ensure no undefined values are passed to Firebase
    const safeString = (val) => (val === undefined || val === null) ? "" : val;

    return {
        grid: grid.map(row => row.map(cell => ({
            type: cell.type || 'empty',
            active: !!cell.active,
            roomInstanceId: cell.roomInstanceId || null
        }))),
        
        activeRooms: activeRooms.map(r => ({
            x: r.x, y: r.y, width: r.width, height: r.height,
            roomNumber: r.roomNumber, 
            letter: safeString(r.letter),
            labelX: r.labelX !== undefined ? r.labelX : r.x, 
            labelY: r.labelY !== undefined ? r.labelY : r.y,
            flavor: safeString(r.flavor),
            name: safeString(r.name)
        })),
        
        doors: doors.map(d => ({ x: d.x, y: d.y, facing: d.facing || 0, secret: !!d.secret })),
        
        manualWalls: manualWalls.map(w => ({
            x: w.x, y: w.y, facing: w.facing || 0,
            wallData: w.wallData ? { name: w.wallData.name, size: w.wallData.size } : null // Strip image URL to save space/safety
        })),
        
        placedFurniture: placedFurniture.map(f => ({
            x: f.x, y: f.y, facing: f.facing || 0,
            furniture: f.furniture ? { name: f.furniture.name, size: f.furniture.size } : null
        })),
        
        placedMonsters: placedMonsters.map(m => ({
            x: m.x, y: m.y, facing: m.facing || 0,
            type: m.type ? { name: m.type.name, size: m.type.size } : null
        })),
        
        placedTraps: placedTraps.map(t => ({ x: t.x, y: t.y, type: t.type })),
        
        // Save Text Boxes
        placedTexts: placedTexts.map(t => ({...t})),

        // Metadata (Sanitized)
        questName: safeString((document.getElementById('shareName') && document.getElementById('shareName').value) ? document.getElementById('shareName').value : (currentQuest ? currentQuest.name : "Custom Quest")),
        questDesc: safeString((document.getElementById('shareDesc') && document.getElementById('shareDesc').value) ? document.getElementById('shareDesc').value : (currentQuest ? currentQuest.flavor : "")),
        questTags: safeString((document.getElementById('shareTags') && document.getElementById('shareTags').value) ? document.getElementById('shareTags').value : (currentQuest ? currentQuest.tags : "")),

        // Full Definition (Sanitized via JSON cycle)
        questDefinition: currentQuest ? JSON.parse(JSON.stringify(currentQuest)) : null,
        
        useCustomLayout: !!useCustomLayout
    };
}

function loadQuestData(data) {
    if (data.grid) {
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                Object.assign(grid[y][x], data.grid[y][x]);
            }
        }
    }

    activeRooms = data.activeRooms || [];
    doors = data.doors || [];
    manualWalls = data.manualWalls || [];
    placedFurniture = data.placedFurniture || [];
    placedMonsters = data.placedMonsters || [];
    placedTraps = data.placedTraps || [];
    
    // NEW: Load Texts
    placedTexts = data.placedTexts || [];
    
    useCustomLayout = data.useCustomLayout;

    // Rebuild room spaces
    activeRooms.forEach(r => {
        if (!r.spaces && r.width && r.height) {
            r.spaces = [];
            for (let i = 0; i < r.width; i++) {
                for (let j = 0; j < r.height; j++) {
                    r.spaces.push({ x: r.x + i, y: r.y + j });
                }
            }
        }
    });

    rebuildOccupancy();

    if (data.questDefinition) {
        if (!currentQuest) currentQuest = {};
        Object.assign(currentQuest, data.questDefinition);
    } else if (!currentQuest) {
        currentQuest = { name: data.questName || "Loaded Quest", rooms: [] };
    }

    if (document.getElementById('shareName')) document.getElementById('shareName').value = data.questName || currentQuest.name;
    if (document.getElementById('shareDesc')) document.getElementById('shareDesc').value = data.questDesc || currentQuest.flavor;
    if (document.getElementById('shareTags')) document.getElementById('shareTags').value = data.questTags || "";

    // Clear editing text state
    if(document.getElementById('textEditorToolbar')) document.getElementById('textEditorToolbar').style.display = 'none';
    editingTextItem = null;

    updateQuestUI();
    drawBoard();
}

        function toggleAuthModal() {
            const m = document.getElementById('authModal');
            const o = document.getElementById('overlay');
            if (!m) return;
            const isVisible = m.style.display === 'block';
            m.style.display = isVisible ? 'none' : 'block';
            o.style.display = isVisible ? 'none' : 'block';

            // Reset to login mode when opening
            if (!isVisible) {
                document.getElementById('authTitle').innerText = 'Login';
                document.getElementById('authActionBtn').innerText = 'Login';
                document.getElementById('authDisplayName').style.display = 'none';
                document.getElementById('authSwitchBtn').innerText = "Don't have an account? Register";
                document.getElementById('authError').style.display = 'none';
            }
        }

        function toggleAuthMode() {
            const title = document.getElementById('authTitle');
            const btn = document.getElementById('authActionBtn');
            const nameInput = document.getElementById('authDisplayName');
            const switchBtn = document.getElementById('authSwitchBtn');

            if (title.innerText === 'Login') {
                title.innerText = 'Register';
                btn.innerText = 'Register';
                nameInput.style.display = 'block';
                switchBtn.innerText = "Already have an account? Login";
            } else {
                title.innerText = 'Login';
                btn.innerText = 'Login';
                nameInput.style.display = 'none';
                switchBtn.innerText = "Don't have an account? Register";
            }
        }

        // 2. AUTH LOGIC
        function handleAuth() {
            const email = document.getElementById('authEmail').value;
            const pass = document.getElementById('authPassword').value;
            const name = document.getElementById('authDisplayName').value;
            const mode = document.getElementById('authTitle').innerText;
            const errorDiv = document.getElementById('authError');

            if (!email || !pass) {
                errorDiv.innerText = "Please fill in all fields.";
                errorDiv.style.display = 'block';
                return;
            }

            if (mode === 'Register') {
                auth.createUserWithEmailAndPassword(email, pass)
                    .then((cred) => {
                        if (name) {
                            cred.user.updateProfile({ displayName: name }).then(() => {
                                database.ref('users/' + cred.user.uid).set({
                                    displayName: name,
                                    email: email,
                                    joined: Date.now()
                                });
                                updateAuthUI(cred.user);
                                toggleAuthModal();
                            });
                        } else {
                            updateAuthUI(cred.user);
                            toggleAuthModal();
                        }
                    })
                    .catch((error) => {
                        errorDiv.innerText = error.message;
                        errorDiv.style.display = 'block';
                    });
            } else {
                auth.signInWithEmailAndPassword(email, pass)
                    .then((cred) => {
                        updateAuthUI(cred.user);
                        toggleAuthModal();
                    })
                    .catch((error) => {
                        errorDiv.innerText = error.message;
                        errorDiv.style.display = 'block';
                    });
            }
        }

        function updateAuthUI(user) {
            currentUser = user;
            const authBtn = document.getElementById('authBtn');
            const profileChip = document.getElementById('userProfileDisplay');
            const avatar = document.getElementById('userAvatarSmall');
            const name = document.getElementById('userNameSmall');

            if (user) {
                authBtn.style.display = 'none';
                profileChip.style.display = 'flex';
                name.innerText = user.displayName || user.email;
                avatar.src = user.photoURL || 'https://via.placeholder.com/30';
            } else {
                authBtn.style.display = 'inline-block';
                profileChip.style.display = 'none';
            }
        }

        auth.onAuthStateChanged((user) => {
            updateAuthUI(user);
        });

        // 3. PROFILE LOGIC
        function toggleProfileModal() {
            const m = document.getElementById('profileModal');
            const o = document.getElementById('overlay');
            const isVisible = m.style.display === 'block';

            if (!isVisible && currentUser) {
                document.getElementById('profileName').value = currentUser.displayName || '';
                document.getElementById('profileAvatar').src = currentUser.photoURL || 'https://via.placeholder.com/80';
                database.ref('users/' + currentUser.uid + '/bio').once('value').then(snap => {
                    document.getElementById('profileBio').value = snap.val() || '';
                });
            }

            m.style.display = isVisible ? 'none' : 'block';
            o.style.display = isVisible ? 'none' : 'block';
        }

        function saveProfile() {
            const name = document.getElementById('profileName').value;
            const bio = document.getElementById('profileBio').value;

            if (currentUser) {
                currentUser.updateProfile({ displayName: name }).then(() => {
                    database.ref('users/' + currentUser.uid).update({
                        displayName: name,
                        bio: bio
                    });
                    updateAuthUI(currentUser);
                    toggleProfileModal();
                });
            }
        }

        function promptAvatar() {
            const url = prompt("Enter Image URL for Avatar:");
            if (url && currentUser) {
                currentUser.updateProfile({ photoURL: url }).then(() => {
                    document.getElementById('profileAvatar').src = url;
                    database.ref('users/' + currentUser.uid).update({ photoUrl: url });
                });
            }
        }

        // --- ROOM NOTES LOGIC ---
        function toggleRoomNotes() {
            const m = document.getElementById('roomNotesModal');
            const o = document.getElementById('overlay');
            const isVisible = m.style.display === 'block';
            m.style.display = isVisible ? 'none' : 'block';
            o.style.display = isVisible ? 'none' : 'block';

            if (!isVisible) {
                const list = document.getElementById('roomNotesList');
                list.innerHTML = '';

                // Sort active rooms by Letter or Number
                const rooms = activeRooms.sort((a, b) => (a.letter || '').localeCompare(b.letter || ''));

                rooms.forEach((r, idx) => {
                    const label = r.letter ? "Room " + r.letter : "Room " + r.roomNumber;
                    const div = document.createElement('div');
                    div.style.marginBottom = '10px';
                    div.innerHTML = '<label style="font-weight:bold; font-size:12px;">' + label + '</label>' +
                        '<textarea id="note_room_' + idx + '" class="auth-input" style="height:50px; font-family:Arial;" placeholder="Enter room description...">' + (r.flavor || '') + '</textarea>';
                    list.appendChild(div);
                });
            }
        }

        function saveRoomNotes() {
            // Save from inputs back to activeRooms
            activeRooms.sort((a, b) => (a.letter || '').localeCompare(b.letter || '')).forEach((r, idx) => {
                const input = document.getElementById('note_room_' + idx);
                if (input) r.flavor = input.value;
            });
            alert("Room Notes Updated!");
            toggleRoomNotes();
        }

        // --- PRELOADER FIX v2 ---
        function preloadImages() {
            const allImages = [
                ...Object.values(FURNITURE_IMAGES),
                ...Object.values(WALL_IMAGES),
                ...Object.values(DOOR_IMAGES),
                ...Object.values(MONSTER_IMAGES),
                ...Object.values(TRAP_IMAGES)
            ];

            const loadImage = (src) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = "anonymous";

                    // Increased timeout to 5000ms to ensure all assets load effectively
                    const timer = setTimeout(() => {
                        console.warn("Time out loading:", src);
                        resolve(null);
                    }, 5000);

                    img.onload = () => {
                        clearTimeout(timer);
                        imageCache[src] = img;
                        resolve(img);
                    };
                    img.onerror = () => {
                        clearTimeout(timer);
                        resolve(null);
                    };
                    img.src = src;
                });
            };

            // Process all images
            return Promise.all(allImages.map(src => loadImage(src)));
        }

        // --- BOOT ---
        let isGameInitialized = false;

        // Validated Boot Logic
        window.onload = () => {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            if (document.getElementById('backgroundImage')) {
                document.getElementById('backgroundImage').style.visibility = 'visible';
            }
            initHelpSystem(); // Initialize Help Content
            preloadImages().then(() => {
                console.log("Images preloaded (or timed out)");
                if (!isGameInitialized) {
                    initializeGrid();
                    generateQuest();
                    isGameInitialized = true;
                } else {
                    // If user manually generated while waiting, just redraw to show icons
                    drawBoard();
                }
            });
        };

        // Event Listeners
        document.getElementById('generateButton').onclick = () => {
            useCustomLayout = false;
            generateQuest();
            isGameInitialized = true;
        };
        document.getElementById('downloadButton').onclick = () => downloadQuest('png');

        // ADD THIS HERE:
        canvas.addEventListener('contextmenu', (e) => {
            if (isEditMode || isQuestEditMode) {
                e.preventDefault();
            }
        }, false);


    </script>
    <script>
        function updateQuestData(field, value) {
            if (!currentQuest) return;
            // Map 'name' to 'title' if needed, but currentQuest uses 'name' in definitions
            if (field === 'name') currentQuest.name = value;
            if (field === 'flavor') currentQuest.flavor = value;
            if (field === 'goal') currentQuest.goal = value;
            if (field === 'rewards') currentQuest.rewards = value;
        }

        function updateRoomData(roomLetter, field, value) {
            const room = activeRooms.find(r => r.letter === roomLetter);
            if (!room) return;
            if (field === 'name') room.name = value;
            if (field === 'flavor') room.flavor = value;

            // Also update the quest definition reference so re-renders work
            if (currentQuest && currentQuest.rooms) {
                const questRoom = currentQuest.rooms.find(qr => qr.letter === roomLetter);
                if (questRoom) {
                    if (field === 'name') questRoom.name = value;
                    if (field === 'flavor') questRoom.flavor = value;
                }
            }
        }
    </script>
    <!-- Existing html2canvas library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- NEW: jsPDF library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</body>

<script>
    // --- UI Redesign Logic ---
    function toggleMenu() {
        const d = document.getElementById("mainMenuDropdown");
        if (d.style.display === "flex") d.style.display = "none";
        else d.style.display = "flex";
    }

    // Close menu when clicking outside
    window.onclick = function (event) {
        if (!event.target.matches('.menu-btn') && !event.target.closest('.dropdown-content')) {
            const d = document.getElementById("mainMenuDropdown");
            if (d && d.style.display === "flex") d.style.display = "none";
        }
    }

    function toggleRoomLabels() {
        const cb = document.getElementById('showRoomNumbers');
        if (cb) {
            cb.checked = !cb.checked;
            drawBoard(); // Redraw to apply
            updateRoomLabelBtn();
        }
    }

    function updateRoomLabelBtn() {
        const cb = document.getElementById('showRoomNumbers');
        const btn = document.getElementById('roomLabelToggleBtn');
        if (cb && btn) {
            if (cb.checked) {
                btn.classList.add('toggle-active');
                btn.innerText = "Room Labels: ON";
                btn.style.background = "#4CAF50";
            } else {
                btn.classList.remove('toggle-active');
                btn.innerText = "Room Labels: OFF";
                btn.style.background = "#555";
            }
        }
    }

    // Init Button State
    updateRoomLabelBtn();

    // --- ADVANCED HELP SYSTEM ---
    let originalHelpContent = {};
    let helpInitialized = false;

    function initHelpSystem() {
        if (helpInitialized) return;
        document.querySelectorAll('.help-panel').forEach(p => {
            originalHelpContent[p.id] = p.innerHTML;
        });
        helpInitialized = true;
    }

    function switchHelpTab(tabId) {
        // 1. Hide all panels
        document.querySelectorAll('.help-panel').forEach(p => p.classList.remove('active'));
        // 2. Show selected
        const selected = document.getElementById(tabId);
        if (selected) selected.classList.add('active');

        // 3. Update Sidebar Active State
        document.querySelectorAll('.help-tab').forEach(t => {
            t.classList.remove('active');
            if (t.getAttribute('onclick') && t.getAttribute('onclick').includes(tabId)) {
                t.classList.add('active');
            }
        });
    }

    function searchHelp() {
        if (!helpInitialized) initHelpSystem();
        const term = document.getElementById('helpSearch').value.trim();

        // Restore all if empty
        if (!term) {
            for (const [id, html] of Object.entries(originalHelpContent)) {
                const el = document.getElementById(id);
                if (el) el.innerHTML = html;
            }
            return;
        }

        if (term.length < 2) return;

        const regex = new RegExp(`(${term})`, 'gi');
        let firstMatchId = null;

        for (const [id, html] of Object.entries(originalHelpContent)) {
            const panel = document.getElementById(id);
            if (!panel) continue;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;

            const walk = document.createTreeWalker(tempDiv, NodeFilter.SHOW_TEXT, null, false);
            let node;
            let hasMatch = false;
            const nodesToReplace = [];

            while (node = walk.nextNode()) {
                if (node.nodeValue && node.nodeValue.match(regex)) {
                    hasMatch = true;
                    nodesToReplace.push(node);
                }
            }

            nodesToReplace.forEach(n => {
                const span = document.createElement('span');
                span.innerHTML = n.nodeValue.replace(regex, '<mark class="highlight">$1</mark>');
                if (n.parentNode) n.parentNode.replaceChild(span, n);
            });

            if (hasMatch) {
                panel.innerHTML = tempDiv.innerHTML;
                if (!firstMatchId) firstMatchId = id;
            } else {
                panel.innerHTML = html; // No match in this panel, restore original
            }
        }

        if (firstMatchId) {
            switchHelpTab(firstMatchId);
        }
    }

</script>
</body>

</html>
